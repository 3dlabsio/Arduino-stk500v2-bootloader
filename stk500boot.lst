   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  **** License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  **** Date:      17 October 2007
  12:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  13:stk500boot.c  **** Compiler:  WINAVR20060421
  14:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  **** DESCRIPTION:
  17:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****     "reset" vector in Application area.
  22:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  23:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  24:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  **** USAGE:
  27:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****     - AVRISP will detect the bootloader
  38:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  **** Note:
  41:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****     Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  **** 	AVRdude:
  46:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  **** NOTES:
  51:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  **** LICENSE:
  55:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****     any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****     GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  **** *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  79:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  80:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  81:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  82:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  83:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  84:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  86:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  89:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  90:stk500boot.c  **** //*	Apr 21, 2020    <PE>  Updated to compile under avr-gcc version 7.3.0
  91:stk500boot.c  **** //*	Apr 21, 2020    <PE>  Issue https://github.com/msproul/Arduino-stk500v2-bootloader/issues/7
  92:stk500boot.c  **** //************************************************************************
  93:stk500boot.c  **** 
  94:stk500boot.c  **** //************************************************************************
  95:stk500boot.c  **** //*	these are used to test issues
  96:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  97:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  98:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  99:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
 100:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
 101:stk500boot.c  **** #define	_FIX_ISSUE_505_
 102:stk500boot.c  **** //************************************************************************
 103:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 104:stk500boot.c  **** #define	_FIX_ISSUE_181_
 105:stk500boot.c  **** 
 106:stk500boot.c  **** #include	<inttypes.h>
 107:stk500boot.c  **** #include	<avr/io.h>
 108:stk500boot.c  **** #include	<avr/interrupt.h>
 109:stk500boot.c  **** #include	<avr/boot.h>
 110:stk500boot.c  **** #include	<avr/pgmspace.h>
 111:stk500boot.c  **** #include	<util/delay.h>
 112:stk500boot.c  **** #include	<avr/eeprom.h>
 113:stk500boot.c  **** #include	<avr/common.h>
 114:stk500boot.c  **** #include	<stdlib.h>
 115:stk500boot.c  **** #include	"command.h"
 116:stk500boot.c  **** 
 117:stk500boot.c  **** 
 118:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 119:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 120:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 121:stk500boot.c  **** 	#define		ENABLE_MONITOR
 122:stk500boot.c  **** 	static void	RunMonitor(void);
 123:stk500boot.c  **** #endif
 124:stk500boot.c  **** 
 125:stk500boot.c  **** #ifndef EEWE
 126:stk500boot.c  **** 	#define EEWE    1
 127:stk500boot.c  **** #endif
 128:stk500boot.c  **** #ifndef EEMWE
 129:stk500boot.c  **** 	#define EEMWE   2
 130:stk500boot.c  **** #endif
 131:stk500boot.c  **** 
 132:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 133:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 134:stk500boot.c  **** 
 135:stk500boot.c  **** 
 136:stk500boot.c  **** /*
 137:stk500boot.c  ****  * Uncomment the following lines to save code space
 138:stk500boot.c  ****  */
 139:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 140:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 141:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 142:stk500boot.c  **** //
 143:stk500boot.c  **** 
 144:stk500boot.c  **** 
 145:stk500boot.c  **** 
 146:stk500boot.c  **** //************************************************************************
 147:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 148:stk500boot.c  **** //*	indicates that bootloader is active
 149:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 150:stk500boot.c  **** //************************************************************************
 151:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 152:stk500boot.c  **** 
 153:stk500boot.c  **** #ifdef _MEGA_BOARD_
 154:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 155:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 156:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 157:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 158:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 159:stk500boot.c  **** 	//*	onbarod led is PORTE4
 160:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 161:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 162:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 163:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 164:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 165:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 166:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 167:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 168:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 169:stk500boot.c  **** #elif defined( _PENGUINO_ )
 170:stk500boot.c  **** 	//*	this is for the Penguino
 171:stk500boot.c  **** 	//*	onbarod led is PORTE4
 172:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 173:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 174:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 175:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 176:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 177:stk500boot.c  **** 	//*	onbarod led is PORTE4
 178:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 179:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 180:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 181:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 182:stk500boot.c  **** 	//*	onbarod led is PORTA7
 183:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 184:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 185:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 186:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 187:stk500boot.c  **** 
 188:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 189:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 190:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 191:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 192:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 193:stk500boot.c  **** 
 194:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 195:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 196:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 197:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 198:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 199:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 200:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 201:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 202:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 203:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 204:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 205:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 206:stk500boot.c  **** #elif defined( _AVRLIP_ )
 207:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 208:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 209:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 210:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 211:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 212:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 213:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 214:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 215:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 216:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 217:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 218:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 219:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 220:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 221:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 222:stk500boot.c  **** #else
 223:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 224:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 225:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 226:stk500boot.c  **** #endif
 227:stk500boot.c  **** 
 228:stk500boot.c  **** 
 229:stk500boot.c  **** 
 230:stk500boot.c  **** /*
 231:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 232:stk500boot.c  ****  */
 233:stk500boot.c  **** #ifndef F_CPU
 234:stk500boot.c  **** 	#define F_CPU 16000000UL
 235:stk500boot.c  **** #endif
 236:stk500boot.c  **** 
 237:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 238:stk500boot.c  **** /*
 239:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 240:stk500boot.c  ****  */
 241:stk500boot.c  **** 
 242:stk500boot.c  **** #ifndef BAUDRATE
 243:stk500boot.c  **** 	#define BAUDRATE 115200
 244:stk500boot.c  **** #endif
 245:stk500boot.c  **** 
 246:stk500boot.c  **** /*
 247:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 248:stk500boot.c  ****  */
 249:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 250:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 251:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 252:stk500boot.c  **** 	#else
 253:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 254:stk500boot.c  **** 	#endif
 255:stk500boot.c  **** #endif
 256:stk500boot.c  **** 
 257:stk500boot.c  **** /*
 258:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 259:stk500boot.c  ****  */
 260:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 261:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 262:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 263:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 264:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 265:stk500boot.c  **** 
 266:stk500boot.c  **** /*
 267:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 268:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 269:stk500boot.c  ****  */
 270:stk500boot.c  **** //#define BOOTSIZE 1024
 271:stk500boot.c  **** #if FLASHEND > 0x0F000
 272:stk500boot.c  **** 	#define BOOTSIZE 8192
 273:stk500boot.c  **** 	#define APP_END  (FLASHEND - BOOTSIZE + 1)
 274:stk500boot.c  **** #else
 275:stk500boot.c  **** 	#define BOOTSIZE 2048
 276:stk500boot.c  **** 	#define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 277:stk500boot.c  **** #endif
 278:stk500boot.c  **** 
 279:stk500boot.c  **** /*
 280:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 281:stk500boot.c  ****  */
 282:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 283:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 284:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 285:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 286:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 287:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 288:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 289:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 290:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 291:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 292:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 293:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 294:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 295:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 296:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 297:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 298:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 299:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 300:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 301:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 302:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 303:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 304:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 305:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 306:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 307:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 308:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 309:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 310:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 311:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 312:stk500boot.c  **** #else
 313:stk500boot.c  **** 	#error "no signature definition for MCU available"
 314:stk500boot.c  **** #endif
 315:stk500boot.c  **** 
 316:stk500boot.c  **** 
 317:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 318:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 319:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 320:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 321:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 322:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 323:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 324:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 325:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 326:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 327:stk500boot.c  **** 
 328:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 329:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 330:stk500boot.c  **** 	/* ATMega8 with one USART */
 331:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 332:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 333:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 334:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 335:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 336:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 337:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 338:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 339:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 340:stk500boot.c  **** 
 341:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 342:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 343:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 344:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 345:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 346:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 347:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 348:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 349:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 350:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 351:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 352:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 353:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 354:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 355:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 356:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 357:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 358:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 359:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 360:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 361:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 362:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 363:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 364:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 365:stk500boot.c  **** 	//* catch all
 366:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 367:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 368:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 369:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 370:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 371:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 372:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 373:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 374:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 375:stk500boot.c  **** #else
 376:stk500boot.c  **** 	#error "no UART definition for MCU available"
 377:stk500boot.c  **** #endif
 378:stk500boot.c  **** 
 379:stk500boot.c  **** 
 380:stk500boot.c  **** 
 381:stk500boot.c  **** /*
 382:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 383:stk500boot.c  ****  */
 384:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 385:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 386:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 387:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 388:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 389:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 390:stk500boot.c  **** #else
 391:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 392:stk500boot.c  **** #endif
 393:stk500boot.c  **** 
 394:stk500boot.c  **** 
 395:stk500boot.c  **** /*
 396:stk500boot.c  ****  * States used in the receive state machine
 397:stk500boot.c  ****  */
 398:stk500boot.c  **** #define	ST_START		0
 399:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 400:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 401:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 402:stk500boot.c  **** #define ST_GET_TOKEN	4
 403:stk500boot.c  **** #define ST_GET_DATA		5
 404:stk500boot.c  **** #define	ST_GET_CHECK	6
 405:stk500boot.c  **** #define	ST_PROCESS		7
 406:stk500boot.c  **** 
 407:stk500boot.c  **** /*
 408:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 409:stk500boot.c  ****  */
 410:stk500boot.c  **** #if defined(RAMPZ)
 411:stk500boot.c  **** 	typedef uint32_t address_t;
 412:stk500boot.c  **** #else
 413:stk500boot.c  **** 	typedef uint16_t address_t;
 414:stk500boot.c  **** #endif
 415:stk500boot.c  **** 
 416:stk500boot.c  **** /*
 417:stk500boot.c  ****  * function prototypes
 418:stk500boot.c  ****  */
 419:stk500boot.c  **** static void sendchar(char c);
 420:stk500boot.c  **** static unsigned char recchar(void);
 421:stk500boot.c  **** 
 422:stk500boot.c  **** /*
 423:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 424:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 425:stk500boot.c  ****  */
 426:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 427:stk500boot.c  **** #include <avr/sfr_defs.h>
 428:stk500boot.c  **** 
 429:stk500boot.c  **** //#define	SPH_REG	0x3E
 430:stk500boot.c  **** //#define	SPL_REG	0x3D
 431:stk500boot.c  **** 
 432:stk500boot.c  **** //*****************************************************************************
 433:stk500boot.c  **** void __jumpMain(void)
 434:stk500boot.c  **** {
 435:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 436:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 437:stk500boot.c  **** 
 438:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 439:stk500boot.c  **** 
 440:stk500boot.c  **** //*	set stack pointer to top of RAM
 441:stk500boot.c  **** 
 442:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 443:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 444:stk500boot.c  **** 
 445:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 446:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 447:stk500boot.c  **** 
 448:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 449:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 450:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 451:stk500boot.c  **** }
 452:stk500boot.c  **** 
 453:stk500boot.c  **** 
 454:stk500boot.c  **** //*****************************************************************************
 455:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 456:stk500boot.c  **** {
 457:stk500boot.c  **** 	unsigned int i;
 458:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 459:stk500boot.c  **** 	{
 460:stk500boot.c  **** 		_delay_ms(0.5);
 461:stk500boot.c  **** 	}
 462:stk500boot.c  **** }
 463:stk500boot.c  **** 
 464:stk500boot.c  **** 
 465:stk500boot.c  **** //*****************************************************************************
 466:stk500boot.c  **** /*
 467:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 468:stk500boot.c  ****  */
 469:stk500boot.c  **** static void sendchar(char c)
 470:stk500boot.c  **** {
  15               		.loc 1 470 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 471:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 471 0
  23 0000 8093 CE00 		sts 206,r24
  24               	.LVL1:
  25               	.L2:
 472:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 472 0 discriminator 1
  27 0004 8091 C800 		lds r24,200
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 473:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 473 0
  31 000c 8091 C800 		lds r24,200
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C800 		sts 200,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE13:
  39               		.section	.text.unlikely,"ax",@progbits
  41               	recchar:
  42               	.LFB15:
 474:stk500boot.c  **** }
 475:stk500boot.c  **** 
 476:stk500boot.c  **** 
 477:stk500boot.c  **** //************************************************************************
 478:stk500boot.c  **** static int	Serial_Available(void)
 479:stk500boot.c  **** {
 480:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 481:stk500boot.c  **** }
 482:stk500boot.c  **** 
 483:stk500boot.c  **** 
 484:stk500boot.c  **** //*****************************************************************************
 485:stk500boot.c  **** /*
 486:stk500boot.c  ****  * Read single byte from USART, block if no data available
 487:stk500boot.c  ****  */
 488:stk500boot.c  **** static unsigned char recchar(void)
 489:stk500boot.c  **** {
  43               		.loc 1 489 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49               	.L7:
 490:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  50               		.loc 1 490 0 discriminator 1
  51 0000 8091 C800 		lds r24,200
  52 0004 87FF      		sbrs r24,7
  53 0006 00C0      		rjmp .L7
 491:stk500boot.c  **** 	{
 492:stk500boot.c  **** 		// wait for data
 493:stk500boot.c  **** 	}
 494:stk500boot.c  **** 	return UART_DATA_REG;
  54               		.loc 1 494 0
  55 0008 8091 CE00 		lds r24,206
 495:stk500boot.c  **** }
  56               		.loc 1 495 0
  57 000c 0895      		ret
  58               		.cfi_endproc
  59               	.LFE15:
  61               		.section	.init9,"ax",@progbits
  62               	.global	__jumpMain
  64               	__jumpMain:
  65               	.LFB11:
 434:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  66               		.loc 1 434 0
  67               		.cfi_startproc
  68               	/* prologue: naked */
  69               	/* frame size = 0 */
  70               	/* stack size = 0 */
  71               	.L__stack_usage = 0
 438:stk500boot.c  **** 
  72               		.loc 1 438 0
  73               	/* #APP */
  74               	 ;  438 "stk500boot.c" 1
  75               		.set __stack, 8703
  76               	 ;  0 "" 2
 442:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  77               		.loc 1 442 0
  78               	 ;  442 "stk500boot.c" 1
  79 0000 01E2      		ldi	16, 33
  80               	 ;  0 "" 2
 443:stk500boot.c  **** 
  81               		.loc 1 443 0
  82               	 ;  443 "stk500boot.c" 1
  83 0002 0EBF      		out 62,16
  84               	 ;  0 "" 2
 445:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  85               		.loc 1 445 0
  86               	 ;  445 "stk500boot.c" 1
  87 0004 0FEF      		ldi	16, 255
  88               	 ;  0 "" 2
 446:stk500boot.c  **** 
  89               		.loc 1 446 0
  90               	 ;  446 "stk500boot.c" 1
  91 0006 0DBF      		out 61,16
  92               	 ;  0 "" 2
 448:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  93               		.loc 1 448 0
  94               	 ;  448 "stk500boot.c" 1
  95 0008 1124      		clr __zero_reg__
  96               	 ;  0 "" 2
 449:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
  97               		.loc 1 449 0
  98               	 ;  449 "stk500boot.c" 1
  99 000a 1FBE      		out 63, __zero_reg__
 100               	 ;  0 "" 2
 450:stk500boot.c  **** }
 101               		.loc 1 450 0
 102               	 ;  450 "stk500boot.c" 1
 103 000c 0C94 0000 		jmp main
 104               	 ;  0 "" 2
 105               	/* epilogue start */
 451:stk500boot.c  **** 
 106               		.loc 1 451 0
 107               	/* #NOAPP */
 108               		.cfi_endproc
 109               	.LFE11:
 111               		.text
 112               	.global	delay_ms
 114               	delay_ms:
 115               	.LFB12:
 456:stk500boot.c  **** 	unsigned int i;
 116               		.loc 1 456 0
 117               		.cfi_startproc
 118               	.LVL3:
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 458:stk500boot.c  **** 	{
 123               		.loc 1 458 0
 124 0018 20E0      		ldi r18,0
 125 001a 30E0      		ldi r19,0
 126               	.LVL4:
 127               	.L11:
 458:stk500boot.c  **** 	{
 128               		.loc 1 458 0 is_stmt 0 discriminator 1
 129 001c 2817      		cp r18,r24
 130 001e 3907      		cpc r19,r25
 131 0020 01F0      		breq .L13
 132               	.LVL5:
 133               	.LBB75:
 134               	.LBB76:
 135               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 136               		.loc 2 187 0 is_stmt 1
 137 0022 EFEC      		ldi r30,lo8(1999)
 138 0024 F7E0      		ldi r31,hi8(1999)
 139 0026 3197      	1:	sbiw r30,1
 140 0028 01F4      		brne 1b
 141 002a 00C0      		rjmp .
 142 002c 0000      		nop
 143               	.LVL6:
 144               	.LBE76:
 145               	.LBE75:
 458:stk500boot.c  **** 	{
 146               		.loc 1 458 0
 147 002e 2F5F      		subi r18,-1
 148 0030 3F4F      		sbci r19,-1
 149               	.LVL7:
 150 0032 00C0      		rjmp .L11
 151               	.L13:
 152               	/* epilogue start */
 462:stk500boot.c  **** 
 153               		.loc 1 462 0
 154 0034 0895      		ret
 155               		.cfi_endproc
 156               	.LFE12:
 158               	.global	PrintFromPROGMEM_p
 160               	PrintFromPROGMEM_p:
 161               	.LFB18:
 496:stk500boot.c  **** 
 497:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 498:stk500boot.c  **** //*****************************************************************************
 499:stk500boot.c  **** static unsigned char recchar_timeout(void)
 500:stk500boot.c  **** {
 501:stk500boot.c  **** uint32_t count = 0;
 502:stk500boot.c  **** 
 503:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 504:stk500boot.c  **** 	{
 505:stk500boot.c  **** 		// wait for data
 506:stk500boot.c  **** 		count++;
 507:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 508:stk500boot.c  **** 		{
 509:stk500boot.c  **** 		unsigned int	data;
 510:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 511:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 512:stk500boot.c  **** 		#else
 513:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 514:stk500boot.c  **** 		#endif
 515:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 516:stk500boot.c  **** 			{
 517:stk500boot.c  **** 				asm volatile(
 518:stk500boot.c  **** 						"clr	r30		\n\t"
 519:stk500boot.c  **** 						"clr	r31		\n\t"
 520:stk500boot.c  **** 						"ijmp	\n\t"
 521:stk500boot.c  **** 						);
 522:stk500boot.c  **** 			}
 523:stk500boot.c  **** 			count	=	0;
 524:stk500boot.c  **** 		}
 525:stk500boot.c  **** 	}
 526:stk500boot.c  **** 	return UART_DATA_REG;
 527:stk500boot.c  **** }
 528:stk500boot.c  **** 
 529:stk500boot.c  **** //*	for watch dog timer startup
 530:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 531:stk500boot.c  **** 
 532:stk500boot.c  **** 
 533:stk500boot.c  **** //*****************************************************************************
 534:stk500boot.c  **** int main(void)
 535:stk500boot.c  **** {
 536:stk500boot.c  **** 	address_t		address			=	0;
 537:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 538:stk500boot.c  **** 	unsigned char	msgParseState;
 539:stk500boot.c  **** 	unsigned int	ii				=	0;
 540:stk500boot.c  **** 	unsigned char	checksum		=	0;
 541:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 542:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 543:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 544:stk500boot.c  **** 	unsigned char	c, *p;
 545:stk500boot.c  **** 	unsigned char   isLeave = 0;
 546:stk500boot.c  **** 
 547:stk500boot.c  **** 	unsigned long	boot_timeout;
 548:stk500boot.c  **** 	unsigned long	boot_timer;
 549:stk500boot.c  **** 	unsigned int	boot_state;
 550:stk500boot.c  **** #ifdef ENABLE_MONITOR
 551:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 552:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 553:stk500boot.c  **** #endif
 554:stk500boot.c  **** 
 555:stk500boot.c  **** 	//*	some chips dont set the stack properly
 556:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 557:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 558:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 559:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 560:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 561:stk500boot.c  **** 
 562:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 563:stk500boot.c  **** 	//************************************************************************
 564:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 565:stk500boot.c  **** 	//*	handle the watch dog timer
 566:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 567:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 568:stk500boot.c  **** 
 569:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 570:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 571:stk500boot.c  **** 	MCUSR	=	0;
 572:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 573:stk500boot.c  **** 	WDTCSR	=	0;
 574:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 575:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 576:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 577:stk500boot.c  **** 	{
 578:stk500boot.c  **** 		app_start();
 579:stk500boot.c  **** 	}
 580:stk500boot.c  **** 	//************************************************************************
 581:stk500boot.c  **** #endif
 582:stk500boot.c  **** 
 583:stk500boot.c  **** 
 584:stk500boot.c  **** 	boot_timer	=	0;
 585:stk500boot.c  **** 	boot_state	=	0;
 586:stk500boot.c  **** 
 587:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 588:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 589:stk500boot.c  **** //	boot_timeout	=	170000;
 590:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 591:stk500boot.c  **** #else
 592:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 593:stk500boot.c  **** #endif
 594:stk500boot.c  **** 	/*
 595:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 596:stk500boot.c  **** 	 */
 597:stk500boot.c  **** 
 598:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 599:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 600:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 601:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 602:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 603:stk500boot.c  **** 
 604:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 605:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 606:stk500boot.c  **** 	{
 607:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 608:stk500boot.c  **** 		delay_ms(100);
 609:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 610:stk500boot.c  **** 		delay_ms(100);
 611:stk500boot.c  **** 	}
 612:stk500boot.c  **** #endif
 613:stk500boot.c  **** 
 614:stk500boot.c  **** #endif
 615:stk500boot.c  **** 	/*
 616:stk500boot.c  **** 	 * Init UART
 617:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 618:stk500boot.c  **** 	 */
 619:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 620:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 621:stk500boot.c  **** #endif
 622:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 623:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 624:stk500boot.c  **** 
 625:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 626:stk500boot.c  **** 
 627:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 628:stk500boot.c  **** //	delay_ms(500);
 629:stk500boot.c  **** 
 630:stk500boot.c  **** 	sendchar('s');
 631:stk500boot.c  **** 	sendchar('t');
 632:stk500boot.c  **** 	sendchar('k');
 633:stk500boot.c  **** //	sendchar('5');
 634:stk500boot.c  **** //	sendchar('0');
 635:stk500boot.c  **** //	sendchar('0');
 636:stk500boot.c  **** 	sendchar('v');
 637:stk500boot.c  **** 	sendchar('2');
 638:stk500boot.c  **** 	sendchar(0x0d);
 639:stk500boot.c  **** 	sendchar(0x0a);
 640:stk500boot.c  **** 
 641:stk500boot.c  **** 	delay_ms(100);
 642:stk500boot.c  **** #endif
 643:stk500boot.c  **** 
 644:stk500boot.c  **** 	while (boot_state==0)
 645:stk500boot.c  **** 	{
 646:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 647:stk500boot.c  **** 		{
 648:stk500boot.c  **** 			_delay_ms(0.001);
 649:stk500boot.c  **** 			boot_timer++;
 650:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 651:stk500boot.c  **** 			{
 652:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 653:stk500boot.c  **** 			}
 654:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 655:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 656:stk500boot.c  **** 			{
 657:stk500boot.c  **** 				//*	toggle the LED
 658:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 659:stk500boot.c  **** 			}
 660:stk500boot.c  **** 		#endif
 661:stk500boot.c  **** 		}
 662:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 663:stk500boot.c  **** 	}
 664:stk500boot.c  **** 
 665:stk500boot.c  **** 
 666:stk500boot.c  **** 	if (boot_state==1)
 667:stk500boot.c  **** 	{
 668:stk500boot.c  **** 		//*	main loop
 669:stk500boot.c  **** 		while (!isLeave)
 670:stk500boot.c  **** 		{
 671:stk500boot.c  **** 			/*
 672:stk500boot.c  **** 			 * Collect received bytes to a complete message
 673:stk500boot.c  **** 			 */
 674:stk500boot.c  **** 			msgParseState	=	ST_START;
 675:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 676:stk500boot.c  **** 			{
 677:stk500boot.c  **** 				if (boot_state==1)
 678:stk500boot.c  **** 				{
 679:stk500boot.c  **** 					boot_state	=	0;
 680:stk500boot.c  **** 					c			=	UART_DATA_REG;
 681:stk500boot.c  **** 				}
 682:stk500boot.c  **** 				else
 683:stk500boot.c  **** 				{
 684:stk500boot.c  **** 				//	c	=	recchar();
 685:stk500boot.c  **** 					c	=	recchar_timeout();
 686:stk500boot.c  **** 					
 687:stk500boot.c  **** 				}
 688:stk500boot.c  **** 
 689:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 690:stk500boot.c  **** 				rcvdCharCntr++;
 691:stk500boot.c  **** 
 692:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 693:stk500boot.c  **** 				{
 694:stk500boot.c  **** 					exPointCntr++;
 695:stk500boot.c  **** 					if (exPointCntr == 3)
 696:stk500boot.c  **** 					{
 697:stk500boot.c  **** 						RunMonitor();
 698:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 699:stk500boot.c  **** 						isLeave			=	1;
 700:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 701:stk500boot.c  **** 						break;
 702:stk500boot.c  **** 					}
 703:stk500boot.c  **** 				}
 704:stk500boot.c  **** 				else
 705:stk500boot.c  **** 				{
 706:stk500boot.c  **** 					exPointCntr	=	0;
 707:stk500boot.c  **** 				}
 708:stk500boot.c  **** 			#endif
 709:stk500boot.c  **** 
 710:stk500boot.c  **** 				switch (msgParseState)
 711:stk500boot.c  **** 				{
 712:stk500boot.c  **** 					case ST_START:
 713:stk500boot.c  **** 						if ( c == MESSAGE_START )
 714:stk500boot.c  **** 						{
 715:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 716:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 717:stk500boot.c  **** 						}
 718:stk500boot.c  **** 						break;
 719:stk500boot.c  **** 
 720:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 721:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 722:stk500boot.c  **** 						seqNum			=	c;
 723:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 724:stk500boot.c  **** 						checksum		^=	c;
 725:stk500boot.c  **** 					#else
 726:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 727:stk500boot.c  **** 						{
 728:stk500boot.c  **** 							seqNum			=	c;
 729:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 730:stk500boot.c  **** 							checksum		^=	c;
 731:stk500boot.c  **** 						}
 732:stk500boot.c  **** 						else
 733:stk500boot.c  **** 						{
 734:stk500boot.c  **** 							msgParseState	=	ST_START;
 735:stk500boot.c  **** 						}
 736:stk500boot.c  **** 					#endif
 737:stk500boot.c  **** 						break;
 738:stk500boot.c  **** 
 739:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 740:stk500boot.c  **** 						msgLength		=	c<<8;
 741:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 742:stk500boot.c  **** 						checksum		^=	c;
 743:stk500boot.c  **** 						break;
 744:stk500boot.c  **** 
 745:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 746:stk500boot.c  **** 						msgLength		|=	c;
 747:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 748:stk500boot.c  **** 						checksum		^=	c;
 749:stk500boot.c  **** 						break;
 750:stk500boot.c  **** 
 751:stk500boot.c  **** 					case ST_GET_TOKEN:
 752:stk500boot.c  **** 						if ( c == TOKEN )
 753:stk500boot.c  **** 						{
 754:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 755:stk500boot.c  **** 							checksum		^=	c;
 756:stk500boot.c  **** 							ii				=	0;
 757:stk500boot.c  **** 						}
 758:stk500boot.c  **** 						else
 759:stk500boot.c  **** 						{
 760:stk500boot.c  **** 							msgParseState	=	ST_START;
 761:stk500boot.c  **** 						}
 762:stk500boot.c  **** 						break;
 763:stk500boot.c  **** 
 764:stk500boot.c  **** 					case ST_GET_DATA:
 765:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 766:stk500boot.c  **** 						checksum		^=	c;
 767:stk500boot.c  **** 						if (ii == msgLength )
 768:stk500boot.c  **** 						{
 769:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 770:stk500boot.c  **** 						}
 771:stk500boot.c  **** 						break;
 772:stk500boot.c  **** 
 773:stk500boot.c  **** 					case ST_GET_CHECK:
 774:stk500boot.c  **** 						if ( c == checksum )
 775:stk500boot.c  **** 						{
 776:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 777:stk500boot.c  **** 						}
 778:stk500boot.c  **** 						else
 779:stk500boot.c  **** 						{
 780:stk500boot.c  **** 							msgParseState	=	ST_START;
 781:stk500boot.c  **** 						}
 782:stk500boot.c  **** 						break;
 783:stk500boot.c  **** 				}	//	switch
 784:stk500boot.c  **** 			}	//	while(msgParseState)
 785:stk500boot.c  **** 
 786:stk500boot.c  **** 			/*
 787:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 788:stk500boot.c  **** 			 */
 789:stk500boot.c  **** 
 790:stk500boot.c  **** 			switch (msgBuffer[0])
 791:stk500boot.c  **** 			{
 792:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 793:stk500boot.c  **** 				case CMD_SPI_MULTI:
 794:stk500boot.c  **** 					{
 795:stk500boot.c  **** 						unsigned char answerByte;
 796:stk500boot.c  **** 						unsigned char flag=0;
 797:stk500boot.c  **** 
 798:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 799:stk500boot.c  **** 						{
 800:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 801:stk500boot.c  **** 
 802:stk500boot.c  **** 							if ( signatureIndex == 0 )
 803:stk500boot.c  **** 							{
 804:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 805:stk500boot.c  **** 							}
 806:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 807:stk500boot.c  **** 							{
 808:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 809:stk500boot.c  **** 							}
 810:stk500boot.c  **** 							else
 811:stk500boot.c  **** 							{
 812:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 813:stk500boot.c  **** 							}
 814:stk500boot.c  **** 						}
 815:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 816:stk500boot.c  **** 						{
 817:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 818:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 819:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 820:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 821:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 822:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 823:stk500boot.c  **** 							{
 824:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 825:stk500boot.c  **** 							}
 826:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 827:stk500boot.c  **** 							{
 828:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 829:stk500boot.c  **** 							}
 830:stk500boot.c  **** 							else
 831:stk500boot.c  **** 							{
 832:stk500boot.c  **** 								answerByte	=	0;
 833:stk500boot.c  **** 							}
 834:stk500boot.c  **** 						}
 835:stk500boot.c  **** 						else
 836:stk500boot.c  **** 						{
 837:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 838:stk500boot.c  **** 						}
 839:stk500boot.c  **** 						if ( !flag )
 840:stk500boot.c  **** 						{
 841:stk500boot.c  **** 							msgLength		=	7;
 842:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 843:stk500boot.c  **** 							msgBuffer[2]	=	0;
 844:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 845:stk500boot.c  **** 							msgBuffer[4]	=	0;
 846:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 847:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 848:stk500boot.c  **** 						}
 849:stk500boot.c  **** 					}
 850:stk500boot.c  **** 					break;
 851:stk500boot.c  **** 	#endif
 852:stk500boot.c  **** 				case CMD_SIGN_ON:
 853:stk500boot.c  **** 					msgLength		=	11;
 854:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 855:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 856:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 857:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 858:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 859:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 860:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 861:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 862:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 863:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 864:stk500boot.c  **** 					break;
 865:stk500boot.c  **** 
 866:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 867:stk500boot.c  **** 					{
 868:stk500boot.c  **** 						unsigned char value;
 869:stk500boot.c  **** 
 870:stk500boot.c  **** 						switch(msgBuffer[1])
 871:stk500boot.c  **** 						{
 872:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 873:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 874:stk500boot.c  **** 							break;
 875:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 876:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 877:stk500boot.c  **** 							break;
 878:stk500boot.c  **** 						case PARAM_HW_VER:
 879:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 880:stk500boot.c  **** 							break;
 881:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 882:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 883:stk500boot.c  **** 							break;
 884:stk500boot.c  **** 						case PARAM_SW_MINOR:
 885:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 886:stk500boot.c  **** 							break;
 887:stk500boot.c  **** 						default:
 888:stk500boot.c  **** 							value	=	0;
 889:stk500boot.c  **** 							break;
 890:stk500boot.c  **** 						}
 891:stk500boot.c  **** 						msgLength		=	3;
 892:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 893:stk500boot.c  **** 						msgBuffer[2]	=	value;
 894:stk500boot.c  **** 					}
 895:stk500boot.c  **** 					break;
 896:stk500boot.c  **** 
 897:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 898:stk500boot.c  **** 					isLeave	=	1;
 899:stk500boot.c  **** 					//*	fall thru
 900:stk500boot.c  **** 
 901:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 902:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 903:stk500boot.c  **** 					msgLength		=	2;
 904:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 905:stk500boot.c  **** 					break;
 906:stk500boot.c  **** 
 907:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 908:stk500boot.c  **** 					{
 909:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 910:stk500boot.c  **** 						unsigned char signature;
 911:stk500boot.c  **** 
 912:stk500boot.c  **** 						if ( signatureIndex == 0 )
 913:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 914:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 915:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 916:stk500boot.c  **** 						else
 917:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 918:stk500boot.c  **** 
 919:stk500boot.c  **** 						msgLength		=	4;
 920:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 921:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 922:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 923:stk500boot.c  **** 					}
 924:stk500boot.c  **** 					break;
 925:stk500boot.c  **** 
 926:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
 927:stk500boot.c  **** 					msgLength		=	4;
 928:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 929:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 930:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 931:stk500boot.c  **** 					break;
 932:stk500boot.c  **** 
 933:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
 934:stk500boot.c  **** 					{
 935:stk500boot.c  **** 						unsigned char fuseBits;
 936:stk500boot.c  **** 
 937:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 938:stk500boot.c  **** 						{
 939:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 940:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 941:stk500boot.c  **** 							else
 942:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 943:stk500boot.c  **** 						}
 944:stk500boot.c  **** 						else
 945:stk500boot.c  **** 						{
 946:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 947:stk500boot.c  **** 						}
 948:stk500boot.c  **** 						msgLength		=	4;
 949:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 950:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 951:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 952:stk500boot.c  **** 					}
 953:stk500boot.c  **** 					break;
 954:stk500boot.c  **** 
 955:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 956:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
 957:stk500boot.c  **** 					{
 958:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
 959:stk500boot.c  **** 
 960:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 961:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 962:stk500boot.c  **** 						boot_spm_busy_wait();
 963:stk500boot.c  **** 
 964:stk500boot.c  **** 						msgLength		=	3;
 965:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 966:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 967:stk500boot.c  **** 					}
 968:stk500boot.c  **** 					break;
 969:stk500boot.c  **** 	#endif
 970:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
 971:stk500boot.c  **** 					eraseAddress	=	0;
 972:stk500boot.c  **** 					msgLength		=	2;
 973:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 974:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 975:stk500boot.c  **** 					break;
 976:stk500boot.c  **** 
 977:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
 978:stk500boot.c  **** 	#if defined(RAMPZ)
 979:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 980:stk500boot.c  **** 	#else
 981:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 982:stk500boot.c  **** 	#endif
 983:stk500boot.c  **** 					msgLength		=	2;
 984:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 985:stk500boot.c  **** 					break;
 986:stk500boot.c  **** 
 987:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
 988:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
 989:stk500boot.c  **** 					{
 990:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 991:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 992:stk500boot.c  **** 						unsigned int	data;
 993:stk500boot.c  **** 						unsigned char	highByte, lowByte;
 994:stk500boot.c  **** 						address_t		tempaddress	=	address;
 995:stk500boot.c  **** 
 996:stk500boot.c  **** 
 997:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 998:stk500boot.c  **** 						{
 999:stk500boot.c  **** 							// erase only main section (bootloader protection)
1000:stk500boot.c  **** 							if (eraseAddress < APP_END )
1001:stk500boot.c  **** 							{
1002:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1003:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1004:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1005:stk500boot.c  **** 							}
1006:stk500boot.c  **** 
1007:stk500boot.c  **** 							/* Write FLASH */
1008:stk500boot.c  **** 							do {
1009:stk500boot.c  **** 								lowByte		=	*p++;
1010:stk500boot.c  **** 								highByte 	=	*p++;
1011:stk500boot.c  **** 
1012:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1013:stk500boot.c  **** 								boot_page_fill(address,data);
1014:stk500boot.c  **** 
1015:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1016:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1017:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1018:stk500boot.c  **** 
1019:stk500boot.c  **** 							boot_page_write(tempaddress);
1020:stk500boot.c  **** 							boot_spm_busy_wait();
1021:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1022:stk500boot.c  **** 						}
1023:stk500boot.c  **** 						else
1024:stk500boot.c  **** 						{
1025:stk500boot.c  **** 						//*	issue 543, this should work, It has not been tested.
1026:stk500boot.c  **** 					//	#if (!defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)  && !defined(__AVR_ATmega
1027:stk500boot.c  **** 						#if (defined(EEARL) && defined(EEARH)  && defined(EEMWE)  && defined(EEWE)  && defined(EEDR))
1028:stk500boot.c  **** 							/* write EEPROM */
1029:stk500boot.c  **** 							do {
1030:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1031:stk500boot.c  **** 								EEARH	=	(address >> 8);
1032:stk500boot.c  **** 								address++;						// Select next EEPROM byte
1033:stk500boot.c  **** 
1034:stk500boot.c  **** 								EEDR	=	*p++;				// get byte from buffer
1035:stk500boot.c  **** 								EECR	|=	(1<<EEMWE);			// Write data into EEPROM
1036:stk500boot.c  **** 								EECR	|=	(1<<EEWE);
1037:stk500boot.c  **** 
1038:stk500boot.c  **** 								while (EECR & (1<<EEWE));	// Wait for write operation to finish
1039:stk500boot.c  **** 								size--;						// Decrease number of bytes to write
1040:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1041:stk500boot.c  **** 						#endif
1042:stk500boot.c  **** 						}
1043:stk500boot.c  **** 							msgLength	=	2;
1044:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1045:stk500boot.c  **** 					}
1046:stk500boot.c  **** 					break;
1047:stk500boot.c  **** 
1048:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1049:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1050:stk500boot.c  **** 					{
1051:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1052:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1053:stk500boot.c  **** 						msgLength				=	size+3;
1054:stk500boot.c  **** 
1055:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1056:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1057:stk500boot.c  **** 						{
1058:stk500boot.c  **** 							unsigned int data;
1059:stk500boot.c  **** 
1060:stk500boot.c  **** 							// Read FLASH
1061:stk500boot.c  **** 							do {
1062:stk500boot.c  **** 						//#if defined(RAMPZ)
1063:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1064:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1065:stk500boot.c  **** 						#else
1066:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1067:stk500boot.c  **** 						#endif
1068:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1069:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1070:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1071:stk500boot.c  **** 								size	-=	2;
1072:stk500boot.c  **** 							}while (size);
1073:stk500boot.c  **** 						}
1074:stk500boot.c  **** 						else
1075:stk500boot.c  **** 						{
1076:stk500boot.c  **** 							/* Read EEPROM */
1077:stk500boot.c  **** 							do {
1078:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1079:stk500boot.c  **** 								EEARH	=	((address >> 8));
1080:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1081:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1082:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1083:stk500boot.c  **** 								size--;
1084:stk500boot.c  **** 							} while (size);
1085:stk500boot.c  **** 						}
1086:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1087:stk500boot.c  **** 					}
1088:stk500boot.c  **** 					break;
1089:stk500boot.c  **** 
1090:stk500boot.c  **** 				default:
1091:stk500boot.c  **** 					msgLength		=	2;
1092:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1093:stk500boot.c  **** 					break;
1094:stk500boot.c  **** 			}
1095:stk500boot.c  **** 
1096:stk500boot.c  **** 			/*
1097:stk500boot.c  **** 			 * Now send answer message back
1098:stk500boot.c  **** 			 */
1099:stk500boot.c  **** 			sendchar(MESSAGE_START);
1100:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1101:stk500boot.c  **** 
1102:stk500boot.c  **** 			sendchar(seqNum);
1103:stk500boot.c  **** 			checksum	^=	seqNum;
1104:stk500boot.c  **** 
1105:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1106:stk500boot.c  **** 			sendchar(c);
1107:stk500boot.c  **** 			checksum	^=	c;
1108:stk500boot.c  **** 
1109:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1110:stk500boot.c  **** 			sendchar(c);
1111:stk500boot.c  **** 			checksum ^= c;
1112:stk500boot.c  **** 
1113:stk500boot.c  **** 			sendchar(TOKEN);
1114:stk500boot.c  **** 			checksum ^= TOKEN;
1115:stk500boot.c  **** 
1116:stk500boot.c  **** 			p	=	msgBuffer;
1117:stk500boot.c  **** 			while ( msgLength )
1118:stk500boot.c  **** 			{
1119:stk500boot.c  **** 				c	=	*p++;
1120:stk500boot.c  **** 				sendchar(c);
1121:stk500boot.c  **** 				checksum ^=c;
1122:stk500boot.c  **** 				msgLength--;
1123:stk500boot.c  **** 			}
1124:stk500boot.c  **** 			sendchar(checksum);
1125:stk500boot.c  **** 			seqNum++;
1126:stk500boot.c  **** 	
1127:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1128:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1129:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1130:stk500boot.c  **** 		#endif
1131:stk500boot.c  **** 
1132:stk500boot.c  **** 		}
1133:stk500boot.c  **** 	}
1134:stk500boot.c  **** 
1135:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1136:stk500boot.c  **** 	//*	this is for debugging it can be removed
1137:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1138:stk500boot.c  **** 	{
1139:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1140:stk500boot.c  **** 		delay_ms(200);
1141:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1142:stk500boot.c  **** 		delay_ms(200);
1143:stk500boot.c  **** 	}
1144:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1145:stk500boot.c  **** #endif
1146:stk500boot.c  **** 
1147:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1148:stk500boot.c  **** 	sendchar('j');
1149:stk500boot.c  **** //	sendchar('u');
1150:stk500boot.c  **** //	sendchar('m');
1151:stk500boot.c  **** //	sendchar('p');
1152:stk500boot.c  **** //	sendchar(' ');
1153:stk500boot.c  **** //	sendchar('u');
1154:stk500boot.c  **** //	sendchar('s');
1155:stk500boot.c  **** //	sendchar('r');
1156:stk500boot.c  **** 	sendchar(0x0d);
1157:stk500boot.c  **** 	sendchar(0x0a);
1158:stk500boot.c  **** 
1159:stk500boot.c  **** 	delay_ms(100);
1160:stk500boot.c  **** #endif
1161:stk500boot.c  **** 
1162:stk500boot.c  **** 
1163:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1164:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1165:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1166:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1167:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1168:stk500boot.c  **** #endif
1169:stk500boot.c  **** 
1170:stk500boot.c  **** 
1171:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1172:stk500boot.c  **** 
1173:stk500boot.c  **** 	/*
1174:stk500boot.c  **** 	 * Now leave bootloader
1175:stk500boot.c  **** 	 */
1176:stk500boot.c  **** 
1177:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1178:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1179:stk500boot.c  **** 
1180:stk500boot.c  **** 
1181:stk500boot.c  **** 	asm volatile(
1182:stk500boot.c  **** 			"clr	r30		\n\t"
1183:stk500boot.c  **** 			"clr	r31		\n\t"
1184:stk500boot.c  **** 			"ijmp	\n\t"
1185:stk500boot.c  **** 			);
1186:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1187:stk500boot.c  **** //					"push r1" "\n\t"
1188:stk500boot.c  **** //					"ret"	 "\n\t"
1189:stk500boot.c  **** //					::);
1190:stk500boot.c  **** 
1191:stk500boot.c  **** 	 /*
1192:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1193:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1194:stk500boot.c  **** 	 * understand this
1195:stk500boot.c  **** 	 */
1196:stk500boot.c  **** 	for(;;);
1197:stk500boot.c  **** }
1198:stk500boot.c  **** 
1199:stk500boot.c  **** /*
1200:stk500boot.c  **** base address = f800
1201:stk500boot.c  **** 
1202:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1203:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1204:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1205:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1206:stk500boot.c  **** avrdude>
1207:stk500boot.c  **** 
1208:stk500boot.c  **** 
1209:stk500boot.c  **** base address = f000
1210:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1211:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1212:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1213:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1214:stk500boot.c  **** avrdude>
1215:stk500boot.c  **** */
1216:stk500boot.c  **** 
1217:stk500boot.c  **** //************************************************************************
1218:stk500boot.c  **** #ifdef ENABLE_MONITOR
1219:stk500boot.c  **** #include	<math.h>
1220:stk500boot.c  **** 
1221:stk500boot.c  **** unsigned long	gRamIndex;
1222:stk500boot.c  **** unsigned long	gFlashIndex;
1223:stk500boot.c  **** unsigned long	gEepromIndex;
1224:stk500boot.c  **** 
1225:stk500boot.c  **** 
1226:stk500boot.c  **** #define	true	1
1227:stk500boot.c  **** #define	false	0
1228:stk500boot.c  **** 
1229:stk500boot.c  **** #include	"avr_cpunames.h"
1230:stk500boot.c  **** 
1231:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1232:stk500boot.c  **** 	#error cpu name not defined
1233:stk500boot.c  **** #endif
1234:stk500boot.c  **** 
1235:stk500boot.c  **** #ifdef _VECTORS_SIZE
1236:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1237:stk500boot.c  **** #else
1238:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1239:stk500boot.c  **** #endif
1240:stk500boot.c  **** 
1241:stk500boot.c  **** 
1242:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1243:stk500boot.c  **** 
1244:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1245:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1246:stk500boot.c  **** #else
1247:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1248:stk500boot.c  **** #endif
1249:stk500boot.c  **** 
1250:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1251:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1252:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1253:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1254:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1255:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1256:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1257:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1258:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1259:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1260:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1261:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1262:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1263:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1264:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1265:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1266:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1267:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1268:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1269:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1270:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1271:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1272:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1273:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1274:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1275:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1276:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1277:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1278:stk500boot.c  **** 
1279:stk500boot.c  **** 
1280:stk500boot.c  **** //************************************************************************
1281:stk500boot.c  **** //*	Help messages
1282:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1283:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1284:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1285:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1286:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1287:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1288:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1289:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1290:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1291:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1292:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1293:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1294:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1295:stk500boot.c  **** 
1296:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1297:stk500boot.c  **** 
1298:stk500boot.c  **** 
1299:stk500boot.c  **** //************************************************************************
1300:stk500boot.c  **** void	PrintFromPROGMEM_p(const char *dataPtr, unsigned char offset)
1301:stk500boot.c  **** {
 162               		.loc 1 1301 0
 163               		.cfi_startproc
 164               	.LVL8:
 165 0036 0F93      		push r16
 166               	.LCFI0:
 167               		.cfi_def_cfa_offset 4
 168               		.cfi_offset 16, -3
 169 0038 1F93      		push r17
 170               	.LCFI1:
 171               		.cfi_def_cfa_offset 5
 172               		.cfi_offset 17, -4
 173 003a CF93      		push r28
 174               	.LCFI2:
 175               		.cfi_def_cfa_offset 6
 176               		.cfi_offset 28, -5
 177 003c DF93      		push r29
 178               	.LCFI3:
 179               		.cfi_def_cfa_offset 7
 180               		.cfi_offset 29, -6
 181               	/* prologue: function */
 182               	/* frame size = 0 */
 183               	/* stack size = 4 */
 184               	.L__stack_usage = 4
 185 003e 8C01      		movw r16,r24
 186 0040 D62F      		mov r29,r22
 187               	.LVL9:
 188               	.L16:
 189               	.LBB77:
1302:stk500boot.c  **** uint8_t	ii;
1303:stk500boot.c  **** char	theChar;
1304:stk500boot.c  **** 
1305:stk500boot.c  **** 	ii			=	offset;
1306:stk500boot.c  **** 	theChar		=	1;
1307:stk500boot.c  **** 
1308:stk500boot.c  **** 	while (theChar != 0)
1309:stk500boot.c  **** 	{
1310:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1311:stk500boot.c  **** 		theChar	=	pgm_read_byte_far(dataPtr + ii);
 190               		.loc 1 1311 0
 191 0042 C801      		movw r24,r16
 192 0044 8D0F      		add r24,r29
 193 0046 911D      		adc r25,__zero_reg__
 194 0048 092E      		mov __tmp_reg__,r25
 195 004a 000C      		lsl r0
 196 004c AA0B      		sbc r26,r26
 197 004e BB0B      		sbc r27,r27
 198               	/* #APP */
 199               	 ;  1311 "stk500boot.c" 1
 200 0050 ABBF      		out 59, r26
 201 0052 FC01      		movw r30, r24
 202 0054 C791      		elpm r28, Z+
 203               		
 204               	 ;  0 "" 2
 205               	.LVL10:
 206               	/* #NOAPP */
 207               	.LBE77:
1312:stk500boot.c  **** 	#else
1313:stk500boot.c  **** 		theChar	=	pgm_read_byte_near(dataPtr + ii);
1314:stk500boot.c  **** 	#endif
1315:stk500boot.c  **** 		if (theChar != 0)
 208               		.loc 1 1315 0
 209 0056 CC23      		tst r28
 210 0058 01F0      		breq .L15
1316:stk500boot.c  **** 		{
1317:stk500boot.c  **** 			sendchar(theChar);
 211               		.loc 1 1317 0
 212 005a 8C2F      		mov r24,r28
 213 005c 0E94 0000 		call sendchar
 214               	.LVL11:
 215               	.L15:
1318:stk500boot.c  **** 		}
1319:stk500boot.c  **** 		ii++;
 216               		.loc 1 1319 0
 217 0060 DF5F      		subi r29,lo8(-(1))
 218               	.LVL12:
1308:stk500boot.c  **** 	{
 219               		.loc 1 1308 0
 220 0062 C111      		cpse r28,__zero_reg__
 221 0064 00C0      		rjmp .L16
 222               	/* epilogue start */
1320:stk500boot.c  **** 	}
1321:stk500boot.c  **** }
 223               		.loc 1 1321 0
 224 0066 DF91      		pop r29
 225               	.LVL13:
 226 0068 CF91      		pop r28
 227 006a 1F91      		pop r17
 228 006c 0F91      		pop r16
 229               	.LVL14:
 230 006e 0895      		ret
 231               		.cfi_endproc
 232               	.LFE18:
 234               	.global	PrintNewLine
 236               	PrintNewLine:
 237               	.LFB19:
1322:stk500boot.c  **** 
1323:stk500boot.c  **** //************************************************************************
1324:stk500boot.c  **** void	PrintNewLine(void)
1325:stk500boot.c  **** {
 238               		.loc 1 1325 0
 239               		.cfi_startproc
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
1326:stk500boot.c  **** 	sendchar(0x0d);
 244               		.loc 1 1326 0
 245 0070 8DE0      		ldi r24,lo8(13)
 246 0072 0E94 0000 		call sendchar
 247               	.LVL15:
1327:stk500boot.c  **** 	sendchar(0x0a);
 248               		.loc 1 1327 0
 249 0076 8AE0      		ldi r24,lo8(10)
 250 0078 0C94 0000 		jmp sendchar
 251               	.LVL16:
 252               		.cfi_endproc
 253               	.LFE19:
 255               		.section	.text.unlikely
 257               	PrintAvailablePort:
 258               	.LFB29:
1328:stk500boot.c  **** }
1329:stk500boot.c  **** 
1330:stk500boot.c  **** 
1331:stk500boot.c  **** //************************************************************************
1332:stk500boot.c  **** void	PrintFromPROGMEMln_p(const char *dataPtr, unsigned char offset)
1333:stk500boot.c  **** {
1334:stk500boot.c  **** 	PrintFromPROGMEM_p(dataPtr, offset);
1335:stk500boot.c  **** 
1336:stk500boot.c  **** 	PrintNewLine();
1337:stk500boot.c  **** }
1338:stk500boot.c  **** 
1339:stk500boot.c  **** 
1340:stk500boot.c  **** //************************************************************************
1341:stk500boot.c  **** void	PrintString(char *textString)
1342:stk500boot.c  **** {
1343:stk500boot.c  **** char	theChar;
1344:stk500boot.c  **** int		ii;
1345:stk500boot.c  **** 
1346:stk500boot.c  **** 	theChar		=	1;
1347:stk500boot.c  **** 	ii			=	0;
1348:stk500boot.c  **** 	while (theChar != 0)
1349:stk500boot.c  **** 	{
1350:stk500boot.c  **** 		theChar	=	textString[ii];
1351:stk500boot.c  **** 		if (theChar != 0)
1352:stk500boot.c  **** 		{
1353:stk500boot.c  **** 			sendchar(theChar);
1354:stk500boot.c  **** 		}
1355:stk500boot.c  **** 		ii++;
1356:stk500boot.c  **** 	}
1357:stk500boot.c  **** }
1358:stk500boot.c  **** 
1359:stk500boot.c  **** //************************************************************************
1360:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1361:stk500boot.c  **** {
1362:stk500boot.c  **** char	theChar;
1363:stk500boot.c  **** 
1364:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1365:stk500boot.c  **** 	if (theChar > 0x39)
1366:stk500boot.c  **** 	{
1367:stk500boot.c  **** 		theChar	+=	7;
1368:stk500boot.c  **** 	}
1369:stk500boot.c  **** 	sendchar(theChar );
1370:stk500boot.c  **** 
1371:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1372:stk500boot.c  **** 	if (theChar > 0x39)
1373:stk500boot.c  **** 	{
1374:stk500boot.c  **** 		theChar	+=	7;
1375:stk500boot.c  **** 	}
1376:stk500boot.c  **** 	sendchar(theChar );
1377:stk500boot.c  **** }
1378:stk500boot.c  **** 
1379:stk500boot.c  **** //************************************************************************
1380:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1381:stk500boot.c  **** {
1382:stk500boot.c  **** int	theChar;
1383:stk500boot.c  **** int	myNumber;
1384:stk500boot.c  **** 
1385:stk500boot.c  **** 	myNumber	=	theNumber;
1386:stk500boot.c  **** 
1387:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1388:stk500boot.c  **** 	{
1389:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1390:stk500boot.c  **** 		sendchar(theChar );
1391:stk500boot.c  **** 	}
1392:stk500boot.c  **** 
1393:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1394:stk500boot.c  **** 	{
1395:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1396:stk500boot.c  **** 		sendchar(theChar );
1397:stk500boot.c  **** 	}
1398:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1399:stk500boot.c  **** 	sendchar(theChar );
1400:stk500boot.c  **** }
1401:stk500boot.c  **** 
1402:stk500boot.c  **** 
1403:stk500boot.c  **** 
1404:stk500boot.c  **** 
1405:stk500boot.c  **** //************************************************************************
1406:stk500boot.c  **** static void	PrintCPUstats(void)
1407:stk500boot.c  **** {
1408:stk500boot.c  **** unsigned char fuseByte;
1409:stk500boot.c  **** 
1410:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_Explorer, 0);
1411:stk500boot.c  **** 
1412:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_COMPILED_ON, 0);
1413:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_GCC_DATE_STR, 0);
1414:stk500boot.c  **** 
1415:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_CPU_Type, 0);
1416:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_CPU_Name, 0);
1417:stk500boot.c  **** 
1418:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_AVR_ARCH, 0);
1419:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1420:stk500boot.c  **** 	PrintNewLine();
1421:stk500boot.c  **** 
1422:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_GCC_VERSION, 0);
1423:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_GCC_VERSION_STR, 0);
1424:stk500boot.c  **** 
1425:stk500boot.c  **** 	//*	these can be found in avr/version.h
1426:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_AVR_LIBC, 0);
1427:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_AVR_LIBC_VER_STR, 0);
1428:stk500boot.c  **** 
1429:stk500boot.c  **** #if defined(SIGNATURE_0)
1430:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_CPU_SIGNATURE, 0);
1431:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1432:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1433:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1434:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1435:stk500boot.c  **** 	PrintNewLine();
1436:stk500boot.c  **** #endif
1437:stk500boot.c  **** 
1438:stk500boot.c  **** 
1439:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1440:stk500boot.c  **** 	//*	fuse settings
1441:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_FUSE_BYTE_LOW, 0);
1442:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1443:stk500boot.c  **** 	PrintHexByte(fuseByte);
1444:stk500boot.c  **** 	PrintNewLine();
1445:stk500boot.c  **** 
1446:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_FUSE_BYTE_HIGH, 0);
1447:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1448:stk500boot.c  **** 	PrintHexByte(fuseByte);
1449:stk500boot.c  **** 	PrintNewLine();
1450:stk500boot.c  **** 
1451:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_FUSE_BYTE_EXT, 0);
1452:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1453:stk500boot.c  **** 	PrintHexByte(fuseByte);
1454:stk500boot.c  **** 	PrintNewLine();
1455:stk500boot.c  **** 
1456:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_FUSE_BYTE_LOCK, 0);
1457:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1458:stk500boot.c  **** 	PrintHexByte(fuseByte);
1459:stk500boot.c  **** 	PrintNewLine();
1460:stk500boot.c  **** 
1461:stk500boot.c  **** #endif
1462:stk500boot.c  **** 
1463:stk500boot.c  **** }
1464:stk500boot.c  **** 
1465:stk500boot.c  **** 
1466:stk500boot.c  **** //************************************************************************
1467:stk500boot.c  **** static void BlinkLED(void)
1468:stk500boot.c  **** {
1469:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1470:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1471:stk500boot.c  **** 
1472:stk500boot.c  **** 	while (!Serial_Available())
1473:stk500boot.c  **** 	{
1474:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1475:stk500boot.c  **** 		delay_ms(100);
1476:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1477:stk500boot.c  **** 		delay_ms(100);
1478:stk500boot.c  **** 	}
1479:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1480:stk500boot.c  **** }
1481:stk500boot.c  **** 
1482:stk500boot.c  **** enum
1483:stk500boot.c  **** {
1484:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1485:stk500boot.c  **** 	kDUMP_EEPROM,
1486:stk500boot.c  **** 	kDUMP_RAM
1487:stk500boot.c  **** };
1488:stk500boot.c  **** 
1489:stk500boot.c  **** //************************************************************************
1490:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1491:stk500boot.c  **** {
1492:stk500boot.c  **** unsigned long	myAddressPointer;
1493:stk500boot.c  **** uint8_t			ii;
1494:stk500boot.c  **** unsigned char	theValue;
1495:stk500boot.c  **** char			asciiDump[18];
1496:stk500boot.c  **** unsigned char	*ramPtr;
1497:stk500boot.c  **** 
1498:stk500boot.c  **** 
1499:stk500boot.c  **** 	ramPtr				=	0;
1500:stk500boot.c  **** 	theValue			=	0;
1501:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1502:stk500boot.c  **** 	while (numRows > 0)
1503:stk500boot.c  **** 	{
1504:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1505:stk500boot.c  **** 		{
1506:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1507:stk500boot.c  **** 		}
1508:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1509:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1510:stk500boot.c  **** 		sendchar(0x20);
1511:stk500boot.c  **** 		sendchar('-');
1512:stk500boot.c  **** 		sendchar(0x20);
1513:stk500boot.c  **** 
1514:stk500boot.c  **** 		asciiDump[0]		=	0;
1515:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1516:stk500boot.c  **** 		{
1517:stk500boot.c  **** 			switch(dumpWhat)
1518:stk500boot.c  **** 			{
1519:stk500boot.c  **** 				case kDUMP_FLASH:
1520:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1521:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1522:stk500boot.c  **** 				#else
1523:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1524:stk500boot.c  **** 				#endif
1525:stk500boot.c  **** 					break;
1526:stk500boot.c  **** 
1527:stk500boot.c  **** 				case kDUMP_EEPROM:
1528:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1529:stk500boot.c  **** 					break;
1530:stk500boot.c  **** 
1531:stk500boot.c  **** 				case kDUMP_RAM:
1532:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1533:stk500boot.c  **** 					break;
1534:stk500boot.c  **** 
1535:stk500boot.c  **** 			}
1536:stk500boot.c  **** 			PrintHexByte(theValue);
1537:stk500boot.c  **** 			sendchar(0x20);
1538:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1539:stk500boot.c  **** 			{
1540:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1541:stk500boot.c  **** 			}
1542:stk500boot.c  **** 			else
1543:stk500boot.c  **** 			{
1544:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1545:stk500boot.c  **** 			}
1546:stk500boot.c  **** 
1547:stk500boot.c  **** 			myAddressPointer++;
1548:stk500boot.c  **** 		}
1549:stk500boot.c  **** 		asciiDump[16]	=	0;
1550:stk500boot.c  **** 		PrintString(asciiDump);
1551:stk500boot.c  **** 		PrintNewLine();
1552:stk500boot.c  **** 
1553:stk500boot.c  **** 		numRows--;
1554:stk500boot.c  **** 	}
1555:stk500boot.c  **** }
1556:stk500boot.c  **** 
1557:stk500boot.c  **** 
1558:stk500boot.c  **** 
1559:stk500boot.c  **** //************************************************************************
1560:stk500boot.c  **** //*	returns amount of extended memory
1561:stk500boot.c  **** static void	EEPROMtest(void)
1562:stk500boot.c  **** {
1563:stk500boot.c  **** int		ii;
1564:stk500boot.c  **** char	theChar;
1565:stk500boot.c  **** char	theEEPROMchar;
1566:stk500boot.c  **** int		errorCount;
1567:stk500boot.c  **** 
1568:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_WriteToEEprom, 0);
1569:stk500boot.c  **** 	PrintNewLine();
1570:stk500boot.c  **** 	ii			=	0;
1571:stk500boot.c  **** #if (FLASHEND > 0x10000)
1572:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1573:stk500boot.c  **** #else
1574:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1575:stk500boot.c  **** #endif
1576:stk500boot.c  **** 	{
1577:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1578:stk500boot.c  **** 		if (theChar == 0)
1579:stk500boot.c  **** 		{
1580:stk500boot.c  **** 			PrintFromPROGMEM_p(gTextMsg_SPACE, 0);
1581:stk500boot.c  **** 		}
1582:stk500boot.c  **** 		else
1583:stk500boot.c  **** 		{
1584:stk500boot.c  **** 			sendchar(theChar);
1585:stk500boot.c  **** 		}
1586:stk500boot.c  **** 		ii++;
1587:stk500boot.c  **** 	}
1588:stk500boot.c  **** 
1589:stk500boot.c  **** 	//*	no go back through and test
1590:stk500boot.c  **** 	PrintNewLine();
1591:stk500boot.c  **** 	PrintNewLine();
1592:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_ReadingEEprom, 0);
1593:stk500boot.c  **** 	PrintNewLine();
1594:stk500boot.c  **** 	errorCount	=	0;
1595:stk500boot.c  **** 	ii			=	0;
1596:stk500boot.c  **** #if (FLASHEND > 0x10000)
1597:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1598:stk500boot.c  **** #else
1599:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1600:stk500boot.c  **** #endif
1601:stk500boot.c  **** 	{
1602:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1603:stk500boot.c  **** 		if (theEEPROMchar == 0)
1604:stk500boot.c  **** 		{
1605:stk500boot.c  **** 			PrintFromPROGMEM_p(gTextMsg_SPACE, 0);
1606:stk500boot.c  **** 		}
1607:stk500boot.c  **** 		else
1608:stk500boot.c  **** 		{
1609:stk500boot.c  **** 			sendchar(theEEPROMchar);
1610:stk500boot.c  **** 		}
1611:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1612:stk500boot.c  **** 		{
1613:stk500boot.c  **** 			errorCount++;
1614:stk500boot.c  **** 		}
1615:stk500boot.c  **** 		ii++;
1616:stk500boot.c  **** 	}
1617:stk500boot.c  **** 	PrintNewLine();
1618:stk500boot.c  **** 	PrintNewLine();
1619:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_EEPROMerrorCnt, 0);
1620:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1621:stk500boot.c  **** 	PrintNewLine();
1622:stk500boot.c  **** 	PrintNewLine();
1623:stk500boot.c  **** 
1624:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1625:stk500boot.c  **** 
1626:stk500boot.c  **** }
1627:stk500boot.c  **** 
1628:stk500boot.c  **** 
1629:stk500boot.c  **** 
1630:stk500boot.c  **** #if (FLASHEND > 0x08000)
1631:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough 
1632:stk500boot.c  **** //*	memory to include this
1633:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1634:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1635:stk500boot.c  **** //		#warning Interrupt vectors not defined
1636:stk500boot.c  **** //	#endif
1637:stk500boot.c  **** #endif
1638:stk500boot.c  **** 
1639:stk500boot.c  **** //************************************************************************
1640:stk500boot.c  **** static void	VectorDisplay(void)
1641:stk500boot.c  **** {
1642:stk500boot.c  **** unsigned long	byte1;
1643:stk500boot.c  **** unsigned long	byte2;
1644:stk500boot.c  **** unsigned long	byte3;
1645:stk500boot.c  **** unsigned long	byte4;
1646:stk500boot.c  **** unsigned long	word1;
1647:stk500boot.c  **** unsigned long	word2;
1648:stk500boot.c  **** int				vectorIndex;
1649:stk500boot.c  **** unsigned long	myMemoryPtr;
1650:stk500boot.c  **** unsigned long	wordMemoryAddress;
1651:stk500boot.c  **** unsigned long	realitiveAddr;
1652:stk500boot.c  **** unsigned long	myFullAddress;
1653:stk500boot.c  **** unsigned long	absoluteAddr;
1654:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1655:stk500boot.c  **** 	long		stringPointer;
1656:stk500boot.c  **** #endif
1657:stk500boot.c  **** 
1658:stk500boot.c  **** 	myMemoryPtr		=	0;
1659:stk500boot.c  **** 	vectorIndex		=	0;
1660:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_CPU_Name, 0);
1661:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_VECTOR_HEADER, 0);
1662:stk500boot.c  **** 	//					 V#   ADDR   op code
1663:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1664:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1665:stk500boot.c  **** 	{
1666:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1667:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1668:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1669:stk500boot.c  **** 		sendchar(0x20);
1670:stk500boot.c  **** 		sendchar('-');
1671:stk500boot.c  **** 		sendchar(0x20);
1672:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1673:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1674:stk500boot.c  **** 		sendchar(0x20);
1675:stk500boot.c  **** 		sendchar('=');
1676:stk500boot.c  **** 		sendchar(0x20);
1677:stk500boot.c  **** 
1678:stk500boot.c  **** 	
1679:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1680:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1681:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1682:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1683:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1684:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1685:stk500boot.c  **** 	#else
1686:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1687:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1688:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1689:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1690:stk500boot.c  **** 	#endif
1691:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1692:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1693:stk500boot.c  **** 
1694:stk500boot.c  **** 
1695:stk500boot.c  **** 		PrintHexByte(byte2);
1696:stk500boot.c  **** 		sendchar(0x20);
1697:stk500boot.c  **** 		PrintHexByte(byte1);
1698:stk500boot.c  **** 		sendchar(0x20);
1699:stk500boot.c  **** 		PrintHexByte(byte4);
1700:stk500boot.c  **** 		sendchar(0x20);
1701:stk500boot.c  **** 		PrintHexByte(byte3);
1702:stk500boot.c  **** 		sendchar(0x20);
1703:stk500boot.c  **** 	
1704:stk500boot.c  **** 		if (word1 == 0xffff)
1705:stk500boot.c  **** 		{
1706:stk500boot.c  **** 			PrintFromPROGMEM_p(gTextMsg_noVector, 0);
1707:stk500boot.c  **** 		}
1708:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1709:stk500boot.c  **** 		{
1710:stk500boot.c  **** 			//*	rjmp instruction
1711:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1712:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1713:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1714:stk500boot.c  **** 
1715:stk500boot.c  **** 			PrintFromPROGMEM_p(gTextMsg_rjmp, 0);
1716:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1717:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1718:stk500boot.c  **** 			sendchar(0x20);
1719:stk500boot.c  **** 			sendchar('>');
1720:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1721:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1722:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1723:stk500boot.c  **** 	
1724:stk500boot.c  **** 		}
1725:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1726:stk500boot.c  **** 		{
1727:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1728:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1729:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1730:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1731:stk500boot.c  **** 								word2;
1732:stk500boot.c  **** 							
1733:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1734:stk500boot.c  **** 							
1735:stk500boot.c  **** 			PrintFromPROGMEM_p(gTextMsg_jmp, 0);
1736:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1737:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1738:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1739:stk500boot.c  **** 			sendchar(0x20);
1740:stk500boot.c  **** 			sendchar('>');
1741:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1742:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1743:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1744:stk500boot.c  **** 		}
1745:stk500boot.c  **** 
1746:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1747:stk500boot.c  **** 		sendchar(0x20);
1748:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1749:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1750:stk500boot.c  **** 	#else
1751:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1752:stk500boot.c  **** 	#endif
1753:stk500boot.c  **** 		PrintFromPROGMEM_p((char *)stringPointer, 0);
1754:stk500boot.c  **** 	#endif
1755:stk500boot.c  **** 		PrintNewLine();
1756:stk500boot.c  **** 
1757:stk500boot.c  **** 		vectorIndex++;
1758:stk500boot.c  **** 	}
1759:stk500boot.c  **** }
1760:stk500boot.c  **** 
1761:stk500boot.c  **** //************************************************************************
1762:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1763:stk500boot.c  **** {
 259               		.loc 1 1763 0
 260               		.cfi_startproc
 261               	.LVL17:
 262 000e CF93      		push r28
 263               	.LCFI4:
 264               		.cfi_def_cfa_offset 4
 265               		.cfi_offset 28, -3
 266               	/* prologue: function */
 267               	/* frame size = 0 */
 268               	/* stack size = 1 */
 269               	.L__stack_usage = 1
 270 0010 C82F      		mov r28,r24
1764:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_PORT, 0);
 271               		.loc 1 1764 0
 272 0012 60E0      		ldi r22,0
 273 0014 80E0      		ldi r24,lo8(gTextMsg_PORT)
 274 0016 90E0      		ldi r25,hi8(gTextMsg_PORT)
 275               	.LVL18:
 276 0018 0E94 0000 		call PrintFromPROGMEM_p
 277               	.LVL19:
1765:stk500boot.c  **** 	sendchar(thePortLetter);
 278               		.loc 1 1765 0
 279 001c 8C2F      		mov r24,r28
 280 001e 0E94 0000 		call sendchar
 281               	.LVL20:
 282               	/* epilogue start */
1766:stk500boot.c  **** 	PrintNewLine();
1767:stk500boot.c  **** }
 283               		.loc 1 1767 0
 284 0022 CF91      		pop r28
 285               	.LVL21:
1766:stk500boot.c  **** 	PrintNewLine();
 286               		.loc 1 1766 0
 287 0024 0C94 0000 		jmp PrintNewLine
 288               	.LVL22:
 289               		.cfi_endproc
 290               	.LFE29:
 292               		.text
 293               	.global	PrintFromPROGMEMln_p
 295               	PrintFromPROGMEMln_p:
 296               	.LFB20:
1333:stk500boot.c  **** 	PrintFromPROGMEM_p(dataPtr, offset);
 297               		.loc 1 1333 0
 298               		.cfi_startproc
 299               	.LVL23:
 300               	/* prologue: function */
 301               	/* frame size = 0 */
 302               	/* stack size = 0 */
 303               	.L__stack_usage = 0
1334:stk500boot.c  **** 
 304               		.loc 1 1334 0
 305 007c 0E94 0000 		call PrintFromPROGMEM_p
 306               	.LVL24:
1336:stk500boot.c  **** }
 307               		.loc 1 1336 0
 308 0080 0C94 0000 		jmp PrintNewLine
 309               	.LVL25:
 310               		.cfi_endproc
 311               	.LFE20:
 313               	.global	PrintString
 315               	PrintString:
 316               	.LFB21:
1342:stk500boot.c  **** char	theChar;
 317               		.loc 1 1342 0
 318               		.cfi_startproc
 319               	.LVL26:
 320 0084 CF93      		push r28
 321               	.LCFI5:
 322               		.cfi_def_cfa_offset 4
 323               		.cfi_offset 28, -3
 324 0086 DF93      		push r29
 325               	.LCFI6:
 326               		.cfi_def_cfa_offset 5
 327               		.cfi_offset 29, -4
 328               	/* prologue: function */
 329               	/* frame size = 0 */
 330               	/* stack size = 2 */
 331               	.L__stack_usage = 2
 332 0088 EC01      		movw r28,r24
 333               	.LVL27:
 334               	.L26:
1350:stk500boot.c  **** 		if (theChar != 0)
 335               		.loc 1 1350 0
 336 008a 8991      		ld r24,Y+
 337               	.LVL28:
1351:stk500boot.c  **** 		{
 338               		.loc 1 1351 0
 339 008c 8823      		tst r24
 340 008e 01F0      		breq .L24
1353:stk500boot.c  **** 		}
 341               		.loc 1 1353 0
 342 0090 0E94 0000 		call sendchar
 343               	.LVL29:
 344 0094 00C0      		rjmp .L26
 345               	.LVL30:
 346               	.L24:
 347               	/* epilogue start */
1357:stk500boot.c  **** 
 348               		.loc 1 1357 0
 349 0096 DF91      		pop r29
 350 0098 CF91      		pop r28
 351               	.LVL31:
 352 009a 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	PrintHexByte
 358               	PrintHexByte:
 359               	.LFB22:
1361:stk500boot.c  **** char	theChar;
 360               		.loc 1 1361 0
 361               		.cfi_startproc
 362               	.LVL32:
 363 009c CF93      		push r28
 364               	.LCFI7:
 365               		.cfi_def_cfa_offset 4
 366               		.cfi_offset 28, -3
 367               	/* prologue: function */
 368               	/* frame size = 0 */
 369               	/* stack size = 1 */
 370               	.L__stack_usage = 1
 371 009e C82F      		mov r28,r24
1364:stk500boot.c  **** 	if (theChar > 0x39)
 372               		.loc 1 1364 0
 373 00a0 982F      		mov r25,r24
 374 00a2 9295      		swap r25
 375 00a4 9F70      		andi r25,lo8(15)
 376 00a6 80E3      		ldi r24,lo8(48)
 377               	.LVL33:
 378 00a8 890F      		add r24,r25
 379               	.LVL34:
1365:stk500boot.c  **** 	{
 380               		.loc 1 1365 0
 381 00aa 8A33      		cpi r24,lo8(58)
 382 00ac 00F0      		brlo .L28
1367:stk500boot.c  **** 	}
 383               		.loc 1 1367 0
 384 00ae 87E3      		ldi r24,lo8(55)
 385               	.LVL35:
 386 00b0 890F      		add r24,r25
 387               	.LVL36:
 388               	.L28:
1369:stk500boot.c  **** 
 389               		.loc 1 1369 0
 390 00b2 0E94 0000 		call sendchar
 391               	.LVL37:
1371:stk500boot.c  **** 	if (theChar > 0x39)
 392               		.loc 1 1371 0
 393 00b6 CF70      		andi r28,lo8(15)
 394               	.LVL38:
 395 00b8 80E3      		ldi r24,lo8(48)
 396 00ba 8C0F      		add r24,r28
 397               	.LVL39:
1372:stk500boot.c  **** 	{
 398               		.loc 1 1372 0
 399 00bc 8A33      		cpi r24,lo8(58)
 400 00be 00F0      		brlo .L29
1374:stk500boot.c  **** 	}
 401               		.loc 1 1374 0
 402 00c0 87E3      		ldi r24,lo8(55)
 403               	.LVL40:
 404 00c2 8C0F      		add r24,r28
 405               	.LVL41:
 406               	.L29:
 407               	/* epilogue start */
1377:stk500boot.c  **** 
 408               		.loc 1 1377 0
 409 00c4 CF91      		pop r28
1376:stk500boot.c  **** }
 410               		.loc 1 1376 0
 411 00c6 0C94 0000 		jmp sendchar
 412               	.LVL42:
 413               		.cfi_endproc
 414               	.LFE22:
 416               		.section	.text.unlikely
 418               	DumpHex.constprop.0:
 419               	.LFB34:
1490:stk500boot.c  **** {
 420               		.loc 1 1490 0
 421               		.cfi_startproc
 422               	.LVL43:
 423 0028 2F92      		push r2
 424               	.LCFI8:
 425               		.cfi_def_cfa_offset 4
 426               		.cfi_offset 2, -3
 427 002a 3F92      		push r3
 428               	.LCFI9:
 429               		.cfi_def_cfa_offset 5
 430               		.cfi_offset 3, -4
 431 002c 4F92      		push r4
 432               	.LCFI10:
 433               		.cfi_def_cfa_offset 6
 434               		.cfi_offset 4, -5
 435 002e 5F92      		push r5
 436               	.LCFI11:
 437               		.cfi_def_cfa_offset 7
 438               		.cfi_offset 5, -6
 439 0030 6F92      		push r6
 440               	.LCFI12:
 441               		.cfi_def_cfa_offset 8
 442               		.cfi_offset 6, -7
 443 0032 7F92      		push r7
 444               	.LCFI13:
 445               		.cfi_def_cfa_offset 9
 446               		.cfi_offset 7, -8
 447 0034 8F92      		push r8
 448               	.LCFI14:
 449               		.cfi_def_cfa_offset 10
 450               		.cfi_offset 8, -9
 451 0036 9F92      		push r9
 452               	.LCFI15:
 453               		.cfi_def_cfa_offset 11
 454               		.cfi_offset 9, -10
 455 0038 AF92      		push r10
 456               	.LCFI16:
 457               		.cfi_def_cfa_offset 12
 458               		.cfi_offset 10, -11
 459 003a BF92      		push r11
 460               	.LCFI17:
 461               		.cfi_def_cfa_offset 13
 462               		.cfi_offset 11, -12
 463 003c CF92      		push r12
 464               	.LCFI18:
 465               		.cfi_def_cfa_offset 14
 466               		.cfi_offset 12, -13
 467 003e DF92      		push r13
 468               	.LCFI19:
 469               		.cfi_def_cfa_offset 15
 470               		.cfi_offset 13, -14
 471 0040 EF92      		push r14
 472               	.LCFI20:
 473               		.cfi_def_cfa_offset 16
 474               		.cfi_offset 14, -15
 475 0042 FF92      		push r15
 476               	.LCFI21:
 477               		.cfi_def_cfa_offset 17
 478               		.cfi_offset 15, -16
 479 0044 0F93      		push r16
 480               	.LCFI22:
 481               		.cfi_def_cfa_offset 18
 482               		.cfi_offset 16, -17
 483 0046 1F93      		push r17
 484               	.LCFI23:
 485               		.cfi_def_cfa_offset 19
 486               		.cfi_offset 17, -18
 487 0048 CF93      		push r28
 488               	.LCFI24:
 489               		.cfi_def_cfa_offset 20
 490               		.cfi_offset 28, -19
 491 004a DF93      		push r29
 492               	.LCFI25:
 493               		.cfi_def_cfa_offset 21
 494               		.cfi_offset 29, -20
 495 004c CDB7      		in r28,__SP_L__
 496 004e DEB7      		in r29,__SP_H__
 497               	.LCFI26:
 498               		.cfi_def_cfa_register 28
 499 0050 6397      		sbiw r28,19
 500               	.LCFI27:
 501               		.cfi_def_cfa_offset 40
 502 0052 0FB6      		in __tmp_reg__,__SREG__
 503 0054 F894      		cli
 504 0056 DEBF      		out __SP_H__,r29
 505 0058 0FBE      		out __SREG__,__tmp_reg__
 506 005a CDBF      		out __SP_L__,r28
 507               	/* prologue: function */
 508               	/* frame size = 19 */
 509               	/* stack size = 37 */
 510               	.L__stack_usage = 37
 511 005c 082F      		mov r16,r24
 512 005e 6A01      		movw r12,r20
 513 0060 7B01      		movw r14,r22
 514               	.LVL44:
1490:stk500boot.c  **** {
 515               		.loc 1 1490 0
 516 0062 80E1      		ldi r24,lo8(16)
 517 0064 382E      		mov r3,r24
 518               	.LVL45:
1500:stk500boot.c  **** 	myAddressPointer	=	startAddress;
 519               		.loc 1 1500 0
 520 0066 10E0      		ldi r17,0
 521 0068 4E01      		movw r8,r28
 522 006a 81E1      		ldi r24,17
 523 006c 880E      		add r8,r24
 524 006e 911C      		adc r9,__zero_reg__
 525               	.LVL46:
 526               	.L39:
1504:stk500boot.c  **** 		{
 527               		.loc 1 1504 0
 528 0070 91E0      		ldi r25,1
 529 0072 C916      		cp r12,r25
 530 0074 D104      		cpc r13,__zero_reg__
 531 0076 E906      		cpc r14,r25
 532 0078 F104      		cpc r15,__zero_reg__
 533 007a 00F0      		brlo .L31
1506:stk500boot.c  **** 		}
 534               		.loc 1 1506 0
 535 007c 8E2D      		mov r24,r14
 536 007e 0E94 0000 		call PrintHexByte
 537               	.LVL47:
 538               	.L31:
1508:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 539               		.loc 1 1508 0
 540 0082 8D2D      		mov r24,r13
 541 0084 0E94 0000 		call PrintHexByte
 542               	.LVL48:
1509:stk500boot.c  **** 		sendchar(0x20);
 543               		.loc 1 1509 0
 544 0088 8C2D      		mov r24,r12
 545 008a 0E94 0000 		call PrintHexByte
 546               	.LVL49:
1510:stk500boot.c  **** 		sendchar('-');
 547               		.loc 1 1510 0
 548 008e 80E2      		ldi r24,lo8(32)
 549 0090 0E94 0000 		call sendchar
 550               	.LVL50:
1511:stk500boot.c  **** 		sendchar(0x20);
 551               		.loc 1 1511 0
 552 0094 8DE2      		ldi r24,lo8(45)
 553 0096 0E94 0000 		call sendchar
 554               	.LVL51:
1512:stk500boot.c  **** 
 555               		.loc 1 1512 0
 556 009a 80E2      		ldi r24,lo8(32)
 557 009c 0E94 0000 		call sendchar
 558               	.LVL52:
1514:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 559               		.loc 1 1514 0
 560 00a0 1982      		std Y+1,__zero_reg__
 561               	.LVL53:
 562 00a2 FE01      		movw r30,r28
 563 00a4 3196      		adiw r30,1
 564 00a6 5F01      		movw r10,r30
 565 00a8 2601      		movw r4,r12
 566 00aa 3701      		movw r6,r14
 567 00ac 2E2E      		mov r2,r30
 568 00ae BB8A      		std Y+19,r11
 569               	.LVL54:
 570               	.L38:
1517:stk500boot.c  **** 			{
 571               		.loc 1 1517 0
 572 00b0 0130      		cpi r16,lo8(1)
 573 00b2 01F0      		breq .L33
 574 00b4 00F0      		brlo .L34
 575 00b6 0230      		cpi r16,lo8(2)
 576 00b8 01F4      		brne .L32
1532:stk500boot.c  **** 					break;
 577               		.loc 1 1532 0
 578 00ba F201      		movw r30,r4
 579 00bc 1081      		ld r17,Z
 580               	.LVL55:
 581 00be 00C0      		rjmp .L32
 582               	.L34:
 583               	.LVL56:
 584               	.LBB78:
1521:stk500boot.c  **** 				#else
 585               		.loc 1 1521 0
 586               	/* #APP */
 587               	 ;  1521 "stk500boot.c" 1
 588 00c0 6BBE      		out 59, r6
 589 00c2 F201      		movw r30, r4
 590 00c4 1791      		elpm r17, Z+
 591               		
 592               	 ;  0 "" 2
 593               	.LVL57:
 594               	/* #NOAPP */
 595 00c6 00C0      		rjmp .L32
 596               	.LVL58:
 597               	.L33:
 598               	.LBE78:
1528:stk500boot.c  **** 					break;
 599               		.loc 1 1528 0
 600 00c8 C201      		movw r24,r4
 601 00ca 0E94 0000 		call eeprom_read_byte
 602               	.LVL59:
 603 00ce 182F      		mov r17,r24
 604               	.LVL60:
 605               	.L32:
1536:stk500boot.c  **** 			sendchar(0x20);
 606               		.loc 1 1536 0
 607 00d0 812F      		mov r24,r17
 608 00d2 0E94 0000 		call PrintHexByte
 609               	.LVL61:
1537:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 610               		.loc 1 1537 0
 611 00d6 80E2      		ldi r24,lo8(32)
 612 00d8 0E94 0000 		call sendchar
 613               	.LVL62:
1538:stk500boot.c  **** 			{
 614               		.loc 1 1538 0
 615 00dc 80EE      		ldi r24,lo8(-32)
 616 00de 810F      		add r24,r17
 617 00e0 8F35      		cpi r24,lo8(95)
 618 00e2 00F4      		brsh .L36
1540:stk500boot.c  **** 			}
 619               		.loc 1 1540 0
 620 00e4 F501      		movw r30,r10
 621 00e6 1083      		st Z,r17
 622 00e8 00C0      		rjmp .L37
 623               	.L36:
1544:stk500boot.c  **** 			}
 624               		.loc 1 1544 0
 625 00ea 8EE2      		ldi r24,lo8(46)
 626 00ec F501      		movw r30,r10
 627 00ee 8083      		st Z,r24
 628               	.L37:
1547:stk500boot.c  **** 		}
 629               		.loc 1 1547 0
 630 00f0 9FEF      		ldi r25,-1
 631 00f2 491A      		sub r4,r25
 632 00f4 590A      		sbc r5,r25
 633 00f6 690A      		sbc r6,r25
 634 00f8 790A      		sbc r7,r25
 635               	.LVL63:
 636 00fa EFEF      		ldi r30,-1
 637 00fc AE1A      		sub r10,r30
 638 00fe BE0A      		sbc r11,r30
1515:stk500boot.c  **** 		{
 639               		.loc 1 1515 0
 640 0100 A814      		cp r10,r8
 641 0102 B904      		cpc r11,r9
 642 0104 01F4      		brne .L38
 643 0106 F0E1      		ldi r31,16
 644 0108 CF0E      		add r12,r31
 645 010a D11C      		adc r13,__zero_reg__
 646 010c E11C      		adc r14,__zero_reg__
 647 010e F11C      		adc r15,__zero_reg__
1549:stk500boot.c  **** 		PrintString(asciiDump);
 648               		.loc 1 1549 0
 649 0110 198A      		std Y+17,__zero_reg__
1550:stk500boot.c  **** 		PrintNewLine();
 650               		.loc 1 1550 0
 651 0112 822D      		mov r24,r2
 652 0114 9B89      		ldd r25,Y+19
 653 0116 0E94 0000 		call PrintString
 654               	.LVL64:
1551:stk500boot.c  **** 
 655               		.loc 1 1551 0
 656 011a 0E94 0000 		call PrintNewLine
 657               	.LVL65:
 658 011e 3A94      		dec r3
 659               	.LVL66:
1502:stk500boot.c  **** 	{
 660               		.loc 1 1502 0
 661 0120 3110      		cpse r3,__zero_reg__
 662 0122 00C0      		rjmp .L39
 663               	/* epilogue start */
1555:stk500boot.c  **** 
 664               		.loc 1 1555 0
 665 0124 6396      		adiw r28,19
 666 0126 0FB6      		in __tmp_reg__,__SREG__
 667 0128 F894      		cli
 668 012a DEBF      		out __SP_H__,r29
 669 012c 0FBE      		out __SREG__,__tmp_reg__
 670 012e CDBF      		out __SP_L__,r28
 671 0130 DF91      		pop r29
 672 0132 CF91      		pop r28
 673 0134 1F91      		pop r17
 674               	.LVL67:
 675 0136 0F91      		pop r16
 676               	.LVL68:
 677 0138 FF90      		pop r15
 678 013a EF90      		pop r14
 679 013c DF90      		pop r13
 680 013e CF90      		pop r12
 681               	.LVL69:
 682 0140 BF90      		pop r11
 683 0142 AF90      		pop r10
 684 0144 9F90      		pop r9
 685 0146 8F90      		pop r8
 686 0148 7F90      		pop r7
 687 014a 6F90      		pop r6
 688 014c 5F90      		pop r5
 689 014e 4F90      		pop r4
 690 0150 3F90      		pop r3
 691               	.LVL70:
 692 0152 2F90      		pop r2
 693 0154 0895      		ret
 694               		.cfi_endproc
 695               	.LFE34:
 697               		.text
 698               	.global	PrintDecInt
 700               	PrintDecInt:
 701               	.LFB23:
1381:stk500boot.c  **** int	theChar;
 702               		.loc 1 1381 0
 703               		.cfi_startproc
 704               	.LVL71:
 705 00ca 0F93      		push r16
 706               	.LCFI28:
 707               		.cfi_def_cfa_offset 4
 708               		.cfi_offset 16, -3
 709 00cc 1F93      		push r17
 710               	.LCFI29:
 711               		.cfi_def_cfa_offset 5
 712               		.cfi_offset 17, -4
 713 00ce CF93      		push r28
 714               	.LCFI30:
 715               		.cfi_def_cfa_offset 6
 716               		.cfi_offset 28, -5
 717 00d0 DF93      		push r29
 718               	.LCFI31:
 719               		.cfi_def_cfa_offset 7
 720               		.cfi_offset 29, -6
 721               	/* prologue: function */
 722               	/* frame size = 0 */
 723               	/* stack size = 4 */
 724               	.L__stack_usage = 4
 725 00d2 EC01      		movw r28,r24
 726 00d4 8B01      		movw r16,r22
 727               	.LVL72:
1387:stk500boot.c  **** 	{
 728               		.loc 1 1387 0
 729 00d6 8536      		cpi r24,101
 730 00d8 9105      		cpc r25,__zero_reg__
 731 00da 04F4      		brge .L43
1387:stk500boot.c  **** 	{
 732               		.loc 1 1387 0 is_stmt 0 discriminator 1
 733 00dc 6330      		cpi r22,3
 734 00de 7105      		cpc r23,__zero_reg__
 735 00e0 04F0      		brlt .L44
 736               	.L43:
 737               	.LVL73:
1390:stk500boot.c  **** 	}
 738               		.loc 1 1390 0 is_stmt 1
 739 00e2 CE01      		movw r24,r28
 740               	.LVL74:
 741 00e4 64E6      		ldi r22,lo8(100)
 742 00e6 70E0      		ldi r23,0
 743               	.LVL75:
 744 00e8 0E94 0000 		call __divmodhi4
 745               	.LVL76:
 746 00ec 80E3      		ldi r24,lo8(48)
 747 00ee 860F      		add r24,r22
 748 00f0 0E94 0000 		call sendchar
 749               	.LVL77:
 750               	.L44:
1393:stk500boot.c  **** 	{
 751               		.loc 1 1393 0
 752 00f4 CB30      		cpi r28,11
 753 00f6 D105      		cpc r29,__zero_reg__
 754 00f8 04F4      		brge .L45
1393:stk500boot.c  **** 	{
 755               		.loc 1 1393 0 is_stmt 0 discriminator 1
 756 00fa 0230      		cpi r16,2
 757 00fc 1105      		cpc r17,__zero_reg__
 758 00fe 04F0      		brlt .L46
 759               	.L45:
 760               	.LVL78:
1396:stk500boot.c  **** 	}
 761               		.loc 1 1396 0 is_stmt 1
 762 0100 CE01      		movw r24,r28
 763 0102 64E6      		ldi r22,lo8(100)
 764 0104 70E0      		ldi r23,0
 765 0106 0E94 0000 		call __divmodhi4
 766 010a 6AE0      		ldi r22,lo8(10)
 767 010c 70E0      		ldi r23,0
 768 010e 0E94 0000 		call __divmodhi4
 769 0112 80E3      		ldi r24,lo8(48)
 770 0114 860F      		add r24,r22
 771 0116 0E94 0000 		call sendchar
 772               	.LVL79:
 773               	.L46:
1399:stk500boot.c  **** }
 774               		.loc 1 1399 0
 775 011a CE01      		movw r24,r28
 776 011c 6AE0      		ldi r22,lo8(10)
 777 011e 70E0      		ldi r23,0
 778 0120 0E94 0000 		call __divmodhi4
 779 0124 805D      		subi r24,lo8(-(48))
 780               	/* epilogue start */
1400:stk500boot.c  **** 
 781               		.loc 1 1400 0
 782 0126 DF91      		pop r29
 783 0128 CF91      		pop r28
 784               	.LVL80:
 785 012a 1F91      		pop r17
 786 012c 0F91      		pop r16
 787               	.LVL81:
1399:stk500boot.c  **** }
 788               		.loc 1 1399 0
 789 012e 0C94 0000 		jmp sendchar
 790               	.LVL82:
 791               		.cfi_endproc
 792               	.LFE23:
 794               		.section	.text.startup,"ax",@progbits
 795               	.global	main
 797               	main:
 798               	.LFB17:
 535:stk500boot.c  **** 	address_t		address			=	0;
 799               		.loc 1 535 0
 800               		.cfi_startproc
 801 0000 CF93      		push r28
 802               	.LCFI32:
 803               		.cfi_def_cfa_offset 4
 804               		.cfi_offset 28, -3
 805 0002 DF93      		push r29
 806               	.LCFI33:
 807               		.cfi_def_cfa_offset 5
 808               		.cfi_offset 29, -4
 809 0004 CDB7      		in r28,__SP_L__
 810 0006 DEB7      		in r29,__SP_H__
 811               	.LCFI34:
 812               		.cfi_def_cfa_register 28
 813 0008 CE52      		subi r28,46
 814 000a D140      		sbci r29,1
 815               	.LCFI35:
 816               		.cfi_def_cfa_offset 307
 817 000c 0FB6      		in __tmp_reg__,__SREG__
 818 000e F894      		cli
 819 0010 DEBF      		out __SP_H__,r29
 820 0012 0FBE      		out __SREG__,__tmp_reg__
 821 0014 CDBF      		out __SP_L__,r28
 822               	/* prologue: function */
 823               	/* frame size = 302 */
 824               	/* stack size = 304 */
 825               	.L__stack_usage = 304
 826               	.LVL83:
 556:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 827               		.loc 1 556 0
 828               	/* #APP */
 829               	 ;  556 "stk500boot.c" 1
 830               		.set __stack, 8703
 831               	 ;  0 "" 2
 557:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 832               		.loc 1 557 0
 833               	 ;  557 "stk500boot.c" 1
 834 0016 01E2      		ldi	16, 33
 835               	 ;  0 "" 2
 558:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 836               		.loc 1 558 0
 837               	 ;  558 "stk500boot.c" 1
 838 0018 0EBF      		out 62,16
 839               	 ;  0 "" 2
 559:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 840               		.loc 1 559 0
 841               	 ;  559 "stk500boot.c" 1
 842 001a 0FEF      		ldi	16, 255
 843               	 ;  0 "" 2
 560:stk500boot.c  **** 
 844               		.loc 1 560 0
 845               	 ;  560 "stk500boot.c" 1
 846 001c 0DBF      		out 61,16
 847               	 ;  0 "" 2
 567:stk500boot.c  **** 
 848               		.loc 1 567 0
 849               	/* #NOAPP */
 850 001e 94B7      		in r25,0x34
 851               	.LVL84:
 569:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 852               		.loc 1 569 0
 853               	/* #APP */
 854               	 ;  569 "stk500boot.c" 1
 855 0020 F894      		cli
 856               	 ;  0 "" 2
 570:stk500boot.c  **** 	MCUSR	=	0;
 857               		.loc 1 570 0
 858               	 ;  570 "stk500boot.c" 1
 859 0022 A895      		wdr
 860               	 ;  0 "" 2
 571:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 861               		.loc 1 571 0
 862               	/* #NOAPP */
 863 0024 14BE      		out 0x34,__zero_reg__
 572:stk500boot.c  **** 	WDTCSR	=	0;
 864               		.loc 1 572 0
 865 0026 8091 6000 		lds r24,96
 866 002a 8861      		ori r24,lo8(24)
 867 002c 8093 6000 		sts 96,r24
 573:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 868               		.loc 1 573 0
 869 0030 1092 6000 		sts 96,__zero_reg__
 574:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 870               		.loc 1 574 0
 871               	/* #APP */
 872               	 ;  574 "stk500boot.c" 1
 873 0034 7894      		sei
 874               	 ;  0 "" 2
 576:stk500boot.c  **** 	{
 875               		.loc 1 576 0
 876               	/* #NOAPP */
 877 0036 93FF      		sbrs r25,3
 878 0038 00C0      		rjmp .L48
 578:stk500boot.c  **** 	}
 879               		.loc 1 578 0
 880 003a E091 0000 		lds r30,app_start
 881 003e F091 0000 		lds r31,app_start+1
 882 0042 1995      		eicall
 883               	.LVL85:
 884               	.L48:
 600:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 885               		.loc 1 600 0
 886 0044 279A      		sbi 0x4,7
 602:stk500boot.c  **** 
 887               		.loc 1 602 0
 888 0046 2F9A      		sbi 0x5,7
 620:stk500boot.c  **** #endif
 889               		.loc 1 620 0
 890 0048 8091 C800 		lds r24,200
 891 004c 8260      		ori r24,lo8(2)
 892 004e 8093 C800 		sts 200,r24
 622:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 893               		.loc 1 622 0
 894 0052 80E1      		ldi r24,lo8(16)
 895 0054 8093 CC00 		sts 204,r24
 623:stk500boot.c  **** 
 896               		.loc 1 623 0
 897 0058 88E1      		ldi r24,lo8(24)
 898 005a 8093 C900 		sts 201,r24
 625:stk500boot.c  **** 
 899               		.loc 1 625 0
 900               	/* #APP */
 901               	 ;  625 "stk500boot.c" 1
 902 005e 0000      		nop
 903               	 ;  0 "" 2
 904               	/* #NOAPP */
 905 0060 00E0      		ldi r16,0
 906 0062 10E0      		ldi r17,0
 907 0064 C12C      		mov r12,__zero_reg__
 908 0066 D12C      		mov r13,__zero_reg__
 909 0068 7601      		movw r14,r12
 655:stk500boot.c  **** 			{
 910               		.loc 1 655 0
 911 006a A7EC      		ldi r26,lo8(-57)
 912 006c 8A2E      		mov r8,r26
 913 006e ABE1      		ldi r26,lo8(27)
 914 0070 9A2E      		mov r9,r26
 915 0072 A12C      		mov r10,__zero_reg__
 916 0074 B12C      		mov r11,__zero_reg__
 917               	.LVL86:
 918               	.L49:
 919               	.LBB156:
 920               	.LBB157:
 480:stk500boot.c  **** }
 921               		.loc 1 480 0
 922 0076 8091 C800 		lds r24,200
 923               	.LBE157:
 924               	.LBE156:
 646:stk500boot.c  **** 		{
 925               		.loc 1 646 0
 926 007a 87FD      		sbrc r24,7
 927 007c 00C0      		rjmp .L276
 646:stk500boot.c  **** 		{
 928               		.loc 1 646 0 is_stmt 0 discriminator 1
 929 007e 0115      		cp r16,__zero_reg__
 930 0080 1105      		cpc r17,__zero_reg__
 931 0082 01F4      		brne .L276
 932               	.LVL87:
 933               	.LBB158:
 934               	.LBB159:
 935               		.loc 2 187 0 is_stmt 1
 936 0084 25E0      		ldi r18,lo8(5)
 937 0086 2A95      	1:	dec r18
 938 0088 01F4      		brne 1b
 939 008a 0000      		nop
 940               	.LVL88:
 941               	.LBE159:
 942               	.LBE158:
 649:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 943               		.loc 1 649 0
 944 008c 3FEF      		ldi r19,-1
 945 008e C31A      		sub r12,r19
 946 0090 D30A      		sbc r13,r19
 947 0092 E30A      		sbc r14,r19
 948 0094 F30A      		sbc r15,r19
 949               	.LVL89:
 652:stk500boot.c  **** 			}
 950               		.loc 1 652 0
 951 0096 91E0      		ldi r25,lo8(1)
 952 0098 80E0      		ldi r24,0
 953 009a 41E2      		ldi r20,33
 954 009c C416      		cp r12,r20
 955 009e 4EE4      		ldi r20,78
 956 00a0 D406      		cpc r13,r20
 957 00a2 E104      		cpc r14,__zero_reg__
 958 00a4 F104      		cpc r15,__zero_reg__
 959 00a6 00F4      		brsh .L50
 960 00a8 90E0      		ldi r25,0
 961               	.L50:
 962 00aa 092F      		mov r16,r25
 963               	.LVL90:
 964 00ac 182F      		mov r17,r24
 655:stk500boot.c  **** 			{
 965               		.loc 1 655 0
 966 00ae C701      		movw r24,r14
 967 00b0 B601      		movw r22,r12
 968 00b2 A501      		movw r20,r10
 969 00b4 9401      		movw r18,r8
 970 00b6 0E94 0000 		call __udivmodsi4
 971 00ba 672B      		or r22,r23
 972 00bc 682B      		or r22,r24
 973 00be 692B      		or r22,r25
 974 00c0 01F4      		brne .L49
 658:stk500boot.c  **** 			}
 975               		.loc 1 658 0
 976 00c2 85B1      		in r24,0x5
 977 00c4 8058      		subi r24,lo8(-(-128))
 978 00c6 85B9      		out 0x5,r24
 979 00c8 00C0      		rjmp .L49
 980               	.LVL91:
 981               	.L276:
 662:stk500boot.c  **** 	}
 982               		.loc 1 662 0
 983 00ca 0F5F      		subi r16,-1
 984 00cc 1F4F      		sbci r17,-1
 985               	.LVL92:
 666:stk500boot.c  **** 	{
 986               		.loc 1 666 0
 987 00ce 0130      		cpi r16,1
 988 00d0 1105      		cpc r17,__zero_reg__
 989 00d2 01F0      		breq .+4
 990 00d4 0C94 0000 		jmp .L56
 991 00d8 C75D      		subi r28,lo8(-297)
 992 00da DE4F      		sbci r29,hi8(-297)
 993 00dc 1982      		std Y+1,__zero_reg__
 994 00de 1882      		st Y,__zero_reg__
 995 00e0 C952      		subi r28,lo8(297)
 996 00e2 D140      		sbci r29,hi8(297)
 997 00e4 E12C      		mov r14,__zero_reg__
 998 00e6 F12C      		mov r15,__zero_reg__
 999 00e8 CA5D      		subi r28,lo8(-294)
 1000 00ea DE4F      		sbci r29,hi8(-294)
 1001 00ec 1882      		st Y,__zero_reg__
 1002 00ee C652      		subi r28,lo8(294)
 1003 00f0 D140      		sbci r29,hi8(294)
 1004 00f2 712C      		mov r7,__zero_reg__
 1005 00f4 C95D      		subi r28,lo8(-295)
 1006 00f6 DE4F      		sbci r29,hi8(-295)
 1007 00f8 1982      		std Y+1,__zero_reg__
 1008 00fa 1882      		st Y,__zero_reg__
 1009 00fc C752      		subi r28,lo8(295)
 1010 00fe D140      		sbci r29,hi8(295)
 1011 0100 CE5D      		subi r28,lo8(-290)
 1012 0102 DE4F      		sbci r29,hi8(-290)
 1013 0104 1882      		st Y,__zero_reg__
 1014 0106 1982      		std Y+1,__zero_reg__
 1015 0108 1A82      		std Y+2,__zero_reg__
 1016 010a 1B82      		std Y+3,__zero_reg__
 1017 010c C252      		subi r28,lo8(290)
 1018 010e D140      		sbci r29,hi8(290)
 1019 0110 812C      		mov r8,__zero_reg__
 1020 0112 912C      		mov r9,__zero_reg__
 1021 0114 5401      		movw r10,r8
 1022               	.LVL93:
 1023               	.L199:
 625:stk500boot.c  **** 
 1024               		.loc 1 625 0
 1025 0116 20E0      		ldi r18,0
 1026 0118 30E0      		ldi r19,0
 1027 011a 80E0      		ldi r24,0
 1028               	.LVL94:
 1029               	.L200:
 677:stk500boot.c  **** 				{
 1030               		.loc 1 677 0
 1031 011c 0130      		cpi r16,1
 1032 011e 1105      		cpc r17,__zero_reg__
 1033 0120 01F0      		breq .L281
 1034               	.L60:
 625:stk500boot.c  **** 
 1035               		.loc 1 625 0
 1036 0122 41E0      		ldi r20,lo8(1)
 1037 0124 52E1      		ldi r21,lo8(18)
 1038 0126 6AE7      		ldi r22,lo8(122)
 1039 0128 70E0      		ldi r23,0
 1040               	.L59:
 1041               	.LVL95:
 1042               	.LBB160:
 1043               	.LBB161:
 503:stk500boot.c  **** 	{
 1044               		.loc 1 503 0
 1045 012a 9091 C800 		lds r25,200
 1046 012e 97FD      		sbrc r25,7
 1047 0130 00C0      		rjmp .L281
 1048               	.LVL96:
 1049 0132 4150      		subi r20,1
 1050 0134 5109      		sbc r21,__zero_reg__
 1051 0136 6109      		sbc r22,__zero_reg__
 1052 0138 7109      		sbc r23,__zero_reg__
 1053               	.LVL97:
 507:stk500boot.c  **** 		{
 1054               		.loc 1 507 0
 1055 013a 01F4      		brne .L59
 1056               	.LVL98:
 1057               	.LBB162:
 1058               	.LBB163:
 511:stk500boot.c  **** 		#else
 1059               		.loc 1 511 0
 1060               	/* #APP */
 1061               	 ;  511 "stk500boot.c" 1
 1062 013c 6BBF      		out 59, r22
 1063 013e FA01      		movw r30, r20
 1064 0140 4791      		elpm r20, Z+
 1065 0142 5691      		elpm r21, Z
 1066               		
 1067               	 ;  0 "" 2
 1068               	.LVL99:
 1069               	/* #NOAPP */
 1070               	.LBE163:
 515:stk500boot.c  **** 			{
 1071               		.loc 1 515 0
 1072 0144 4F3F      		cpi r20,-1
 1073 0146 5F4F      		sbci r21,-1
 1074 0148 01F0      		breq .L60
 517:stk500boot.c  **** 						"clr	r30		\n\t"
 1075               		.loc 1 517 0
 1076               	/* #APP */
 1077               	 ;  517 "stk500boot.c" 1
 1078 014a EE27      		clr	r30		
 1079 014c FF27      		clr	r31		
 1080 014e 0994      		ijmp	
 1081               		
 1082               	 ;  0 "" 2
 1083               	/* #NOAPP */
 1084 0150 00C0      		rjmp .L60
 1085               	.LVL100:
 1086               	.L281:
 1087               	.LBE162:
 526:stk500boot.c  **** }
 1088               		.loc 1 526 0
 1089 0152 9091 CE00 		lds r25,206
 1090               	.LVL101:
 1091               	.LBE161:
 1092               	.LBE160:
 690:stk500boot.c  **** 
 1093               		.loc 1 690 0
 1094 0156 C75D      		subi r28,lo8(-297)
 1095 0158 DE4F      		sbci r29,hi8(-297)
 1096 015a A881      		ld r26,Y
 1097 015c B981      		ldd r27,Y+1
 1098 015e C952      		subi r28,lo8(297)
 1099 0160 D140      		sbci r29,hi8(297)
 1100 0162 1196      		adiw r26,1
 1101 0164 C75D      		subi r28,lo8(-297)
 1102 0166 DE4F      		sbci r29,hi8(-297)
 1103 0168 B983      		std Y+1,r27
 1104 016a A883      		st Y,r26
 1105 016c C952      		subi r28,lo8(297)
 1106 016e D140      		sbci r29,hi8(297)
 1107               	.LVL102:
 692:stk500boot.c  **** 				{
 1108               		.loc 1 692 0
 1109 0170 9132      		cpi r25,lo8(33)
 1110 0172 01F0      		breq .+2
 1111 0174 00C0      		rjmp .L62
 692:stk500boot.c  **** 				{
 1112               		.loc 1 692 0 is_stmt 0 discriminator 1
 1113 0176 1A97      		sbiw r26,10
 1114 0178 00F0      		brlo .+2
 1115 017a 00C0      		rjmp .L205
 694:stk500boot.c  **** 					if (exPointCntr == 3)
 1116               		.loc 1 694 0 is_stmt 1
 1117 017c BFEF      		ldi r27,-1
 1118 017e EB1A      		sub r14,r27
 1119 0180 FB0A      		sbc r15,r27
 1120               	.LVL103:
 695:stk500boot.c  **** 					{
 1121               		.loc 1 695 0
 1122 0182 E3E0      		ldi r30,3
 1123 0184 EE16      		cp r14,r30
 1124 0186 F104      		cpc r15,__zero_reg__
 1125 0188 01F0      		breq .+2
 1126 018a 00C0      		rjmp .L63
 1127 018c F5E0      		ldi r31,lo8(5)
 1128 018e EF2E      		mov r14,r31
 1129 0190 F12C      		mov r15,__zero_reg__
 1130               	.LVL104:
 1131               	.L66:
 625:stk500boot.c  **** 
 1132               		.loc 1 625 0
 1133 0192 09E1      		ldi r16,lo8(25)
 1134 0194 10E0      		ldi r17,0
 1135               	.LVL105:
 1136               	.L65:
 1137               	.LBB164:
 1138               	.LBB165:
1768:stk500boot.c  **** 
1769:stk500boot.c  **** //************************************************************************
1770:stk500boot.c  **** static void	ListAvailablePorts(void)
1771:stk500boot.c  **** {
1772:stk500boot.c  **** 
1773:stk500boot.c  **** #ifdef DDRA
1774:stk500boot.c  **** 	PrintAvailablePort('A');
1775:stk500boot.c  **** #endif
1776:stk500boot.c  **** 
1777:stk500boot.c  **** #ifdef DDRB
1778:stk500boot.c  **** 	PrintAvailablePort('B');
1779:stk500boot.c  **** #endif
1780:stk500boot.c  **** 
1781:stk500boot.c  **** #ifdef DDRC
1782:stk500boot.c  **** 	PrintAvailablePort('C');
1783:stk500boot.c  **** #endif
1784:stk500boot.c  **** 
1785:stk500boot.c  **** #ifdef DDRD
1786:stk500boot.c  **** 	PrintAvailablePort('D');
1787:stk500boot.c  **** #endif
1788:stk500boot.c  **** 
1789:stk500boot.c  **** #ifdef DDRE
1790:stk500boot.c  **** 	PrintAvailablePort('E');
1791:stk500boot.c  **** #endif
1792:stk500boot.c  **** 
1793:stk500boot.c  **** #ifdef DDRF
1794:stk500boot.c  **** 	PrintAvailablePort('F');
1795:stk500boot.c  **** #endif
1796:stk500boot.c  **** 
1797:stk500boot.c  **** #ifdef DDRG
1798:stk500boot.c  **** 	PrintAvailablePort('G');
1799:stk500boot.c  **** #endif
1800:stk500boot.c  **** 
1801:stk500boot.c  **** #ifdef DDRH
1802:stk500boot.c  **** 	PrintAvailablePort('H');
1803:stk500boot.c  **** #endif
1804:stk500boot.c  **** 
1805:stk500boot.c  **** #ifdef DDRI
1806:stk500boot.c  **** 	PrintAvailablePort('I');
1807:stk500boot.c  **** #endif
1808:stk500boot.c  **** 
1809:stk500boot.c  **** #ifdef DDRJ
1810:stk500boot.c  **** 	PrintAvailablePort('J');
1811:stk500boot.c  **** #endif
1812:stk500boot.c  **** 
1813:stk500boot.c  **** #ifdef DDRK
1814:stk500boot.c  **** 	PrintAvailablePort('K');
1815:stk500boot.c  **** #endif
1816:stk500boot.c  **** 
1817:stk500boot.c  **** #ifdef DDRL
1818:stk500boot.c  **** 	PrintAvailablePort('L');
1819:stk500boot.c  **** #endif
1820:stk500boot.c  **** 
1821:stk500boot.c  **** }
1822:stk500boot.c  **** 
1823:stk500boot.c  **** //************************************************************************
1824:stk500boot.c  **** static void	AVR_PortOutput(void)
1825:stk500boot.c  **** {
1826:stk500boot.c  **** char	portLetter;
1827:stk500boot.c  **** char	getCharFlag;
1828:stk500boot.c  **** 
1829:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_WHAT_PORT, 0);
1830:stk500boot.c  **** 
1831:stk500boot.c  **** 	portLetter	=	recchar();
1832:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1833:stk500boot.c  **** 	sendchar(portLetter);
1834:stk500boot.c  **** 	PrintNewLine();
1835:stk500boot.c  **** 
1836:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1837:stk500boot.c  **** 	{
1838:stk500boot.c  **** 		getCharFlag	=	true;
1839:stk500boot.c  **** 		switch(portLetter)
1840:stk500boot.c  **** 		{
1841:stk500boot.c  **** 		#ifdef DDRA
1842:stk500boot.c  **** 			case 'A':
1843:stk500boot.c  **** 				DDRA	=	0xff;
1844:stk500boot.c  **** 				while (!Serial_Available())
1845:stk500boot.c  **** 				{
1846:stk500boot.c  **** 					PORTA	^=	0xff;
1847:stk500boot.c  **** 					delay_ms(200);
1848:stk500boot.c  **** 				}
1849:stk500boot.c  **** 				PORTA	=	0;
1850:stk500boot.c  **** 				break;
1851:stk500boot.c  **** 		#endif
1852:stk500boot.c  **** 
1853:stk500boot.c  **** 		#ifdef DDRB
1854:stk500boot.c  **** 			case 'B':
1855:stk500boot.c  **** 				DDRB	=	0xff;
1856:stk500boot.c  **** 				while (!Serial_Available())
1857:stk500boot.c  **** 				{
1858:stk500boot.c  **** 					PORTB	^=	0xff;
1859:stk500boot.c  **** 					delay_ms(200);
1860:stk500boot.c  **** 				}
1861:stk500boot.c  **** 				PORTB	=	0;
1862:stk500boot.c  **** 				break;
1863:stk500boot.c  **** 		#endif
1864:stk500boot.c  **** 
1865:stk500boot.c  **** 		#ifdef DDRC
1866:stk500boot.c  **** 			case 'C':
1867:stk500boot.c  **** 				DDRC	=	0xff;
1868:stk500boot.c  **** 				while (!Serial_Available())
1869:stk500boot.c  **** 				{
1870:stk500boot.c  **** 					PORTC	^=	0xff;
1871:stk500boot.c  **** 					delay_ms(200);
1872:stk500boot.c  **** 				}
1873:stk500boot.c  **** 				PORTC	=	0;
1874:stk500boot.c  **** 				break;
1875:stk500boot.c  **** 		#endif
1876:stk500boot.c  **** 
1877:stk500boot.c  **** 		#ifdef DDRD
1878:stk500boot.c  **** 			case 'D':
1879:stk500boot.c  **** 				DDRD	=	0xff;
1880:stk500boot.c  **** 				while (!Serial_Available())
1881:stk500boot.c  **** 				{
1882:stk500boot.c  **** 					PORTD	^=	0xff;
1883:stk500boot.c  **** 					delay_ms(200);
1884:stk500boot.c  **** 				}
1885:stk500boot.c  **** 				PORTD	=	0;
1886:stk500boot.c  **** 				break;
1887:stk500boot.c  **** 		#endif
1888:stk500boot.c  **** 
1889:stk500boot.c  **** 		#ifdef DDRE
1890:stk500boot.c  **** 			case 'E':
1891:stk500boot.c  **** 				DDRE	=	0xff;
1892:stk500boot.c  **** 				while (!Serial_Available())
1893:stk500boot.c  **** 				{
1894:stk500boot.c  **** 					PORTE	^=	0xff;
1895:stk500boot.c  **** 					delay_ms(200);
1896:stk500boot.c  **** 				}
1897:stk500boot.c  **** 				PORTE	=	0;
1898:stk500boot.c  **** 				break;
1899:stk500boot.c  **** 		#endif
1900:stk500boot.c  **** 
1901:stk500boot.c  **** 		#ifdef DDRF
1902:stk500boot.c  **** 			case 'F':
1903:stk500boot.c  **** 				DDRF	=	0xff;
1904:stk500boot.c  **** 				while (!Serial_Available())
1905:stk500boot.c  **** 				{
1906:stk500boot.c  **** 					PORTF	^=	0xff;
1907:stk500boot.c  **** 					delay_ms(200);
1908:stk500boot.c  **** 				}
1909:stk500boot.c  **** 				PORTF	=	0;
1910:stk500boot.c  **** 				break;
1911:stk500boot.c  **** 		#endif
1912:stk500boot.c  **** 
1913:stk500boot.c  **** 		#ifdef DDRG
1914:stk500boot.c  **** 			case 'G':
1915:stk500boot.c  **** 				DDRG	=	0xff;
1916:stk500boot.c  **** 				while (!Serial_Available())
1917:stk500boot.c  **** 				{
1918:stk500boot.c  **** 					PORTG	^=	0xff;
1919:stk500boot.c  **** 					delay_ms(200);
1920:stk500boot.c  **** 				}
1921:stk500boot.c  **** 				PORTG	=	0;
1922:stk500boot.c  **** 				break;
1923:stk500boot.c  **** 		#endif
1924:stk500boot.c  **** 
1925:stk500boot.c  **** 		#ifdef DDRH
1926:stk500boot.c  **** 			case 'H':
1927:stk500boot.c  **** 				DDRH	=	0xff;
1928:stk500boot.c  **** 				while (!Serial_Available())
1929:stk500boot.c  **** 				{
1930:stk500boot.c  **** 					PORTH	^=	0xff;
1931:stk500boot.c  **** 					delay_ms(200);
1932:stk500boot.c  **** 				}
1933:stk500boot.c  **** 				PORTH	=	0;
1934:stk500boot.c  **** 				break;
1935:stk500boot.c  **** 		#endif
1936:stk500boot.c  **** 
1937:stk500boot.c  **** 		#ifdef DDRI
1938:stk500boot.c  **** 			case 'I':
1939:stk500boot.c  **** 				DDRI	=	0xff;
1940:stk500boot.c  **** 				while (!Serial_Available())
1941:stk500boot.c  **** 				{
1942:stk500boot.c  **** 					PORTI	^=	0xff;
1943:stk500boot.c  **** 					delay_ms(200);
1944:stk500boot.c  **** 				}
1945:stk500boot.c  **** 				PORTI	=	0;
1946:stk500boot.c  **** 				break;
1947:stk500boot.c  **** 		#endif
1948:stk500boot.c  **** 
1949:stk500boot.c  **** 		#ifdef DDRJ
1950:stk500boot.c  **** 			case 'J':
1951:stk500boot.c  **** 				DDRJ	=	0xff;
1952:stk500boot.c  **** 				while (!Serial_Available())
1953:stk500boot.c  **** 				{
1954:stk500boot.c  **** 					PORTJ	^=	0xff;
1955:stk500boot.c  **** 					delay_ms(200);
1956:stk500boot.c  **** 				}
1957:stk500boot.c  **** 				PORTJ	=	0;
1958:stk500boot.c  **** 				break;
1959:stk500boot.c  **** 		#endif
1960:stk500boot.c  **** 
1961:stk500boot.c  **** 		#ifdef DDRK
1962:stk500boot.c  **** 			case 'K':
1963:stk500boot.c  **** 				DDRK	=	0xff;
1964:stk500boot.c  **** 				while (!Serial_Available())
1965:stk500boot.c  **** 				{
1966:stk500boot.c  **** 					PORTK	^=	0xff;
1967:stk500boot.c  **** 					delay_ms(200);
1968:stk500boot.c  **** 				}
1969:stk500boot.c  **** 				PORTK	=	0;
1970:stk500boot.c  **** 				break;
1971:stk500boot.c  **** 		#endif
1972:stk500boot.c  **** 
1973:stk500boot.c  **** 		#ifdef DDRL
1974:stk500boot.c  **** 			case 'L':
1975:stk500boot.c  **** 				DDRL	=	0xff;
1976:stk500boot.c  **** 				while (!Serial_Available())
1977:stk500boot.c  **** 				{
1978:stk500boot.c  **** 					PORTL	^=	0xff;
1979:stk500boot.c  **** 					delay_ms(200);
1980:stk500boot.c  **** 				}
1981:stk500boot.c  **** 				PORTL	=	0;
1982:stk500boot.c  **** 				break;
1983:stk500boot.c  **** 		#endif
1984:stk500boot.c  **** 
1985:stk500boot.c  **** 			default:
1986:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_PortNotSupported, 0);
1987:stk500boot.c  **** 				getCharFlag	=	false;
1988:stk500boot.c  **** 				break;
1989:stk500boot.c  **** 		}
1990:stk500boot.c  **** 		if (getCharFlag)
1991:stk500boot.c  **** 		{
1992:stk500boot.c  **** 			recchar();
1993:stk500boot.c  **** 		}
1994:stk500boot.c  **** 	}
1995:stk500boot.c  **** 	else
1996:stk500boot.c  **** 	{
1997:stk500boot.c  **** 		PrintFromPROGMEMln_p(gTextMsg_MustBeLetter, 0);
1998:stk500boot.c  **** 	}
1999:stk500boot.c  **** }
2000:stk500boot.c  **** 
2001:stk500boot.c  **** 
2002:stk500boot.c  **** //*******************************************************************
2003:stk500boot.c  **** static void PrintHelp(void)
2004:stk500boot.c  **** {
2005:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_0, 0);
2006:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_QM, 0);
2007:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_AT, 0);
2008:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_B, 0);
2009:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_E, 0);
2010:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_F, 0);
2011:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_H, 0);
2012:stk500boot.c  **** 
2013:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_L, 0);
2014:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_Q, 0);
2015:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_R, 0);
2016:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_V, 0);
2017:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_Y, 0);
2018:stk500boot.c  **** }
2019:stk500boot.c  **** 
2020:stk500boot.c  **** //************************************************************************
2021:stk500boot.c  **** static void	RunMonitor(void)
2022:stk500boot.c  **** {
2023:stk500boot.c  **** char			keepGoing;
2024:stk500boot.c  **** unsigned char	theChar;
2025:stk500boot.c  **** int				ii, jj;
2026:stk500boot.c  **** 
2027:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
2028:stk500boot.c  **** 	{
2029:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2030:stk500boot.c  **** 		{
2031:stk500boot.c  **** 			sendchar('!');
 1139               		.loc 1 2031 0
 1140 0196 81E2      		ldi r24,lo8(33)
 1141 0198 0E94 0000 		call sendchar
 1142               	.LVL106:
 1143 019c 0150      		subi r16,1
 1144 019e 1109      		sbc r17,__zero_reg__
 1145               	.LVL107:
2029:stk500boot.c  **** 		{
 1146               		.loc 1 2029 0
 1147 01a0 01F4      		brne .L65
2032:stk500boot.c  **** 		}
2033:stk500boot.c  **** 		PrintNewLine();
 1148               		.loc 1 2033 0
 1149 01a2 0E94 0000 		call PrintNewLine
 1150               	.LVL108:
 1151 01a6 F1E0      		ldi r31,1
 1152 01a8 EF1A      		sub r14,r31
 1153 01aa F108      		sbc r15,__zero_reg__
 1154               	.LVL109:
2027:stk500boot.c  **** 	{
 1155               		.loc 1 2027 0
 1156 01ac 01F4      		brne .L66
2034:stk500boot.c  **** 	}
2035:stk500boot.c  **** 
2036:stk500boot.c  **** 	gRamIndex			=	0;
 1157               		.loc 1 2036 0
 1158 01ae 1092 0000 		sts gRamIndex,__zero_reg__
 1159 01b2 1092 0000 		sts gRamIndex+1,__zero_reg__
 1160 01b6 1092 0000 		sts gRamIndex+2,__zero_reg__
 1161 01ba 1092 0000 		sts gRamIndex+3,__zero_reg__
2037:stk500boot.c  **** 	gFlashIndex			=	0;
 1162               		.loc 1 2037 0
 1163 01be 1092 0000 		sts gFlashIndex,__zero_reg__
 1164 01c2 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1165 01c6 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1166 01ca 1092 0000 		sts gFlashIndex+3,__zero_reg__
2038:stk500boot.c  **** 	gEepromIndex		=	0;
 1167               		.loc 1 2038 0
 1168 01ce 1092 0000 		sts gEepromIndex,__zero_reg__
 1169 01d2 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1170 01d6 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1171 01da 1092 0000 		sts gEepromIndex+3,__zero_reg__
2039:stk500boot.c  **** 
2040:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_Explorer, 0);
 1172               		.loc 1 2040 0
 1173 01de 60E0      		ldi r22,0
 1174 01e0 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1175 01e2 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1176 01e4 0E94 0000 		call PrintFromPROGMEMln_p
 1177               	.LVL110:
 1178               	.LBB166:
 1179               	.LBB167:
1903:stk500boot.c  **** 				while (!Serial_Available())
 1180               		.loc 1 1903 0
 1181 01e8 1FEF      		ldi r17,lo8(-1)
 1182               	.LVL111:
 1183               	.L202:
 1184               	.LBE167:
 1185               	.LBE166:
2041:stk500boot.c  **** 
2042:stk500boot.c  **** 	keepGoing	=	1;
2043:stk500boot.c  **** 	while (keepGoing)
2044:stk500boot.c  **** 	{
2045:stk500boot.c  **** 		PrintFromPROGMEM_p(gTextMsg_Prompt, 0);
 1186               		.loc 1 2045 0
 1187 01ea 60E0      		ldi r22,0
 1188 01ec 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 1189 01ee 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 1190 01f0 0E94 0000 		call PrintFromPROGMEM_p
 1191               	.LVL112:
2046:stk500boot.c  **** 		theChar	=	recchar();
 1192               		.loc 1 2046 0
 1193 01f4 0E94 0000 		call recchar
 1194               	.LVL113:
 1195 01f8 082F      		mov r16,r24
 1196               	.LVL114:
2047:stk500boot.c  **** 		if (theChar >= 0x60)
 1197               		.loc 1 2047 0
 1198 01fa 8036      		cpi r24,lo8(96)
 1199 01fc 00F0      		brlo .L68
2048:stk500boot.c  **** 		{
2049:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
 1200               		.loc 1 2049 0
 1201 01fe 0F75      		andi r16,lo8(95)
 1202               	.LVL115:
 1203               	.L68:
2050:stk500boot.c  **** 		}
2051:stk500boot.c  **** 
2052:stk500boot.c  **** 		if (theChar >= 0x20)
 1204               		.loc 1 2052 0
 1205 0200 0032      		cpi r16,lo8(32)
 1206 0202 00F0      		brlo .L69
2053:stk500boot.c  **** 		{
2054:stk500boot.c  **** 			sendchar(theChar);
 1207               		.loc 1 2054 0
 1208 0204 802F      		mov r24,r16
 1209 0206 0E94 0000 		call sendchar
 1210               	.LVL116:
2055:stk500boot.c  **** 			sendchar(0x20);
 1211               		.loc 1 2055 0
 1212 020a 80E2      		ldi r24,lo8(32)
 1213 020c 0E94 0000 		call sendchar
 1214               	.LVL117:
 1215               	.L69:
2056:stk500boot.c  **** 		}
2057:stk500boot.c  **** 
2058:stk500boot.c  **** 		switch(theChar)
 1216               		.loc 1 2058 0
 1217 0210 0634      		cpi r16,lo8(70)
 1218 0212 01F4      		brne .+2
 1219 0214 00C0      		rjmp .L71
 1220 0216 00F0      		brlo .+2
 1221 0218 00C0      		rjmp .L72
 1222 021a 0034      		cpi r16,lo8(64)
 1223 021c 01F4      		brne .+2
 1224 021e 00C0      		rjmp .L73
 1225 0220 00F0      		brlo .+2
 1226 0222 00C0      		rjmp .L74
 1227 0224 0033      		cpi r16,lo8(48)
 1228 0226 01F4      		brne .+2
 1229 0228 00C0      		rjmp .L75
 1230 022a 0F33      		cpi r16,lo8(63)
 1231 022c 01F0      		breq .+2
 1232 022e 00C0      		rjmp .L70
2059:stk500boot.c  **** 		{
2060:stk500boot.c  **** 			case '0':
2061:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_0, 2);
2062:stk500boot.c  **** 				gFlashIndex		=	0;
2063:stk500boot.c  **** 				gRamIndex		=	0;
2064:stk500boot.c  **** 				gEepromIndex	=	0;
2065:stk500boot.c  **** 				break;
2066:stk500boot.c  **** 
2067:stk500boot.c  **** 			case '?':
2068:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_QM, 2);
 1233               		.loc 1 2068 0
 1234 0230 62E0      		ldi r22,lo8(2)
 1235 0232 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1236 0234 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1237 0236 0E94 0000 		call PrintFromPROGMEMln_p
 1238               	.LVL118:
 1239               	.LBB192:
 1240               	.LBB193:
1410:stk500boot.c  **** 
 1241               		.loc 1 1410 0
 1242 023a 60E0      		ldi r22,0
 1243 023c 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1244 023e 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1245 0240 0E94 0000 		call PrintFromPROGMEMln_p
 1246               	.LVL119:
1412:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_GCC_DATE_STR, 0);
 1247               		.loc 1 1412 0
 1248 0244 60E0      		ldi r22,0
 1249 0246 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1250 0248 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1251 024a 0E94 0000 		call PrintFromPROGMEM_p
 1252               	.LVL120:
1413:stk500boot.c  **** 
 1253               		.loc 1 1413 0
 1254 024e 60E0      		ldi r22,0
 1255 0250 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1256 0252 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1257 0254 0E94 0000 		call PrintFromPROGMEMln_p
 1258               	.LVL121:
1415:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_CPU_Name, 0);
 1259               		.loc 1 1415 0
 1260 0258 60E0      		ldi r22,0
 1261 025a 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1262 025c 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1263 025e 0E94 0000 		call PrintFromPROGMEM_p
 1264               	.LVL122:
1416:stk500boot.c  **** 
 1265               		.loc 1 1416 0
 1266 0262 60E0      		ldi r22,0
 1267 0264 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1268 0266 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1269 0268 0E94 0000 		call PrintFromPROGMEMln_p
 1270               	.LVL123:
1418:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 1271               		.loc 1 1418 0
 1272 026c 60E0      		ldi r22,0
 1273 026e 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1274 0270 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1275 0272 0E94 0000 		call PrintFromPROGMEM_p
 1276               	.LVL124:
 1277               	.LBB194:
 1278               	.LBB195:
1399:stk500boot.c  **** }
 1279               		.loc 1 1399 0
 1280 0276 86E3      		ldi r24,lo8(54)
 1281 0278 0E94 0000 		call sendchar
 1282               	.LVL125:
 1283               	.LBE195:
 1284               	.LBE194:
1420:stk500boot.c  **** 
 1285               		.loc 1 1420 0
 1286 027c 0E94 0000 		call PrintNewLine
 1287               	.LVL126:
1422:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_GCC_VERSION_STR, 0);
 1288               		.loc 1 1422 0
 1289 0280 60E0      		ldi r22,0
 1290 0282 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1291 0284 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1292 0286 0E94 0000 		call PrintFromPROGMEM_p
 1293               	.LVL127:
1423:stk500boot.c  **** 
 1294               		.loc 1 1423 0
 1295 028a 60E0      		ldi r22,0
 1296 028c 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1297 028e 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1298 0290 0E94 0000 		call PrintFromPROGMEMln_p
 1299               	.LVL128:
1426:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_AVR_LIBC_VER_STR, 0);
 1300               		.loc 1 1426 0
 1301 0294 60E0      		ldi r22,0
 1302 0296 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1303 0298 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1304 029a 0E94 0000 		call PrintFromPROGMEM_p
 1305               	.LVL129:
1427:stk500boot.c  **** 
 1306               		.loc 1 1427 0
 1307 029e 60E0      		ldi r22,0
 1308 02a0 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1309 02a2 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1310 02a4 0E94 0000 		call PrintFromPROGMEMln_p
 1311               	.LVL130:
1430:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
 1312               		.loc 1 1430 0
 1313 02a8 60E0      		ldi r22,0
 1314 02aa 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1315 02ac 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1316 02ae 0E94 0000 		call PrintFromPROGMEM_p
 1317               	.LVL131:
1432:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1318               		.loc 1 1432 0
 1319 02b2 8EE1      		ldi r24,lo8(30)
 1320 02b4 0E94 0000 		call PrintHexByte
 1321               	.LVL132:
1433:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1322               		.loc 1 1433 0
 1323 02b8 88E9      		ldi r24,lo8(-104)
 1324 02ba 0E94 0000 		call PrintHexByte
 1325               	.LVL133:
1434:stk500boot.c  **** 	PrintNewLine();
 1326               		.loc 1 1434 0
 1327 02be 81E0      		ldi r24,lo8(1)
 1328 02c0 0E94 0000 		call PrintHexByte
 1329               	.LVL134:
1435:stk500boot.c  **** #endif
 1330               		.loc 1 1435 0
 1331 02c4 0E94 0000 		call PrintNewLine
 1332               	.LVL135:
1441:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1333               		.loc 1 1441 0
 1334 02c8 60E0      		ldi r22,0
 1335 02ca 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1336 02cc 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1337 02ce 0E94 0000 		call PrintFromPROGMEM_p
 1338               	.LVL136:
 1339               	.LBB196:
1442:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1340               		.loc 1 1442 0
 1341 02d2 29E0      		ldi r18,lo8(9)
 1342 02d4 E0E0      		ldi r30,0
 1343 02d6 F0E0      		ldi r31,0
 1344               	/* #APP */
 1345               	 ;  1442 "stk500boot.c" 1
 1346 02d8 2093 5700 		sts 87, r18
 1347 02dc 8491      		lpm r24, Z
 1348               		
 1349               	 ;  0 "" 2
 1350               	.LVL137:
 1351               	/* #NOAPP */
 1352               	.LBE196:
1443:stk500boot.c  **** 	PrintNewLine();
 1353               		.loc 1 1443 0
 1354 02de 0E94 0000 		call PrintHexByte
 1355               	.LVL138:
1444:stk500boot.c  **** 
 1356               		.loc 1 1444 0
 1357 02e2 0E94 0000 		call PrintNewLine
 1358               	.LVL139:
1446:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1359               		.loc 1 1446 0
 1360 02e6 60E0      		ldi r22,0
 1361 02e8 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1362 02ea 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1363 02ec 0E94 0000 		call PrintFromPROGMEM_p
 1364               	.LVL140:
 1365               	.LBB197:
1447:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1366               		.loc 1 1447 0
 1367 02f0 29E0      		ldi r18,lo8(9)
 1368 02f2 E3E0      		ldi r30,lo8(3)
 1369 02f4 F0E0      		ldi r31,0
 1370               	/* #APP */
 1371               	 ;  1447 "stk500boot.c" 1
 1372 02f6 2093 5700 		sts 87, r18
 1373 02fa 8491      		lpm r24, Z
 1374               		
 1375               	 ;  0 "" 2
 1376               	.LVL141:
 1377               	/* #NOAPP */
 1378               	.LBE197:
1448:stk500boot.c  **** 	PrintNewLine();
 1379               		.loc 1 1448 0
 1380 02fc 0E94 0000 		call PrintHexByte
 1381               	.LVL142:
1449:stk500boot.c  **** 
 1382               		.loc 1 1449 0
 1383 0300 0E94 0000 		call PrintNewLine
 1384               	.LVL143:
1451:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1385               		.loc 1 1451 0
 1386 0304 60E0      		ldi r22,0
 1387 0306 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1388 0308 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1389 030a 0E94 0000 		call PrintFromPROGMEM_p
 1390               	.LVL144:
 1391               	.LBB198:
1452:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1392               		.loc 1 1452 0
 1393 030e E2E0      		ldi r30,lo8(2)
 1394 0310 F0E0      		ldi r31,0
 1395 0312 39E0      		ldi r19,lo8(9)
 1396               	/* #APP */
 1397               	 ;  1452 "stk500boot.c" 1
 1398 0314 3093 5700 		sts 87, r19
 1399 0318 8491      		lpm r24, Z
 1400               		
 1401               	 ;  0 "" 2
 1402               	.LVL145:
 1403               	/* #NOAPP */
 1404               	.LBE198:
1453:stk500boot.c  **** 	PrintNewLine();
 1405               		.loc 1 1453 0
 1406 031a 0E94 0000 		call PrintHexByte
 1407               	.LVL146:
1454:stk500boot.c  **** 
 1408               		.loc 1 1454 0
 1409 031e 0E94 0000 		call PrintNewLine
 1410               	.LVL147:
1456:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1411               		.loc 1 1456 0
 1412 0322 60E0      		ldi r22,0
 1413 0324 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1414 0326 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1415 0328 0E94 0000 		call PrintFromPROGMEM_p
 1416               	.LVL148:
 1417               	.LBB199:
1457:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1418               		.loc 1 1457 0
 1419 032c E1E0      		ldi r30,lo8(1)
 1420 032e F0E0      		ldi r31,0
 1421 0330 49E0      		ldi r20,lo8(9)
 1422               	/* #APP */
 1423               	 ;  1457 "stk500boot.c" 1
 1424 0332 4093 5700 		sts 87, r20
 1425 0336 8491      		lpm r24, Z
 1426               		
 1427               	 ;  0 "" 2
 1428               	.LVL149:
 1429               	/* #NOAPP */
 1430               	.LBE199:
1458:stk500boot.c  **** 	PrintNewLine();
 1431               		.loc 1 1458 0
 1432 0338 0E94 0000 		call PrintHexByte
 1433               	.LVL150:
1459:stk500boot.c  **** 
 1434               		.loc 1 1459 0
 1435 033c 0E94 0000 		call PrintNewLine
 1436               	.LVL151:
 1437 0340 00C0      		rjmp .L202
 1438               	.LVL152:
 1439               	.L74:
 1440               	.LBE193:
 1441               	.LBE192:
2058:stk500boot.c  **** 		{
 1442               		.loc 1 2058 0
 1443 0342 0234      		cpi r16,lo8(66)
 1444 0344 01F4      		brne .+2
 1445 0346 00C0      		rjmp .L77
 1446 0348 0534      		cpi r16,lo8(69)
 1447 034a 01F4      		brne .+2
 1448 034c 00C0      		rjmp .L78
 1449 034e 00C0      		rjmp .L70
 1450               	.L72:
 1451 0350 0135      		cpi r16,lo8(81)
 1452 0352 01F4      		brne .+2
 1453 0354 00C0      		rjmp .L79
 1454 0356 00F4      		brsh .L80
 1455 0358 0834      		cpi r16,lo8(72)
 1456 035a 01F4      		brne .+2
 1457 035c 00C0      		rjmp .L81
 1458 035e 0C34      		cpi r16,lo8(76)
 1459 0360 01F0      		breq .+2
 1460 0362 00C0      		rjmp .L70
2069:stk500boot.c  **** 				PrintCPUstats();
2070:stk500boot.c  **** 				break;
2071:stk500boot.c  **** 
2072:stk500boot.c  **** 			case '@':
2073:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_AT, 2);
2074:stk500boot.c  **** 				EEPROMtest();
2075:stk500boot.c  **** 				break;
2076:stk500boot.c  **** 
2077:stk500boot.c  **** 			case 'B':
2078:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_B, 2);
2079:stk500boot.c  **** 				BlinkLED();
2080:stk500boot.c  **** 				break;
2081:stk500boot.c  **** 
2082:stk500boot.c  **** 			case 'E':
2083:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_E, 2);
2084:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
2085:stk500boot.c  **** 				gEepromIndex	+=	256;
2086:stk500boot.c  **** 				if (gEepromIndex > E2END)
2087:stk500boot.c  **** 				{
2088:stk500boot.c  **** 					gEepromIndex	=	0;
2089:stk500boot.c  **** 				}
2090:stk500boot.c  **** 				break;
2091:stk500boot.c  **** 		
2092:stk500boot.c  **** 			case 'F':
2093:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_F, 2);
2094:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
2095:stk500boot.c  **** 				gFlashIndex	+=	256;
2096:stk500boot.c  **** 				break;
2097:stk500boot.c  **** 
2098:stk500boot.c  **** 			case 'H':
2099:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_H, 2);
2100:stk500boot.c  **** 				PrintHelp();
2101:stk500boot.c  **** 				break;
2102:stk500boot.c  **** 
2103:stk500boot.c  **** 			case 'L':
2104:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_L, 2);
 1461               		.loc 1 2104 0
 1462 0364 62E0      		ldi r22,lo8(2)
 1463 0366 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1464 0368 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1465 036a 0E94 0000 		call PrintFromPROGMEMln_p
 1466               	.LVL153:
 1467               	.LBB200:
 1468               	.LBB201:
1774:stk500boot.c  **** #endif
 1469               		.loc 1 1774 0
 1470 036e 81E4      		ldi r24,lo8(65)
 1471 0370 0E94 0000 		call PrintAvailablePort
 1472               	.LVL154:
1778:stk500boot.c  **** #endif
 1473               		.loc 1 1778 0
 1474 0374 82E4      		ldi r24,lo8(66)
 1475 0376 0E94 0000 		call PrintAvailablePort
 1476               	.LVL155:
1782:stk500boot.c  **** #endif
 1477               		.loc 1 1782 0
 1478 037a 83E4      		ldi r24,lo8(67)
 1479 037c 0E94 0000 		call PrintAvailablePort
 1480               	.LVL156:
1786:stk500boot.c  **** #endif
 1481               		.loc 1 1786 0
 1482 0380 84E4      		ldi r24,lo8(68)
 1483 0382 0E94 0000 		call PrintAvailablePort
 1484               	.LVL157:
1790:stk500boot.c  **** #endif
 1485               		.loc 1 1790 0
 1486 0386 85E4      		ldi r24,lo8(69)
 1487 0388 0E94 0000 		call PrintAvailablePort
 1488               	.LVL158:
1794:stk500boot.c  **** #endif
 1489               		.loc 1 1794 0
 1490 038c 86E4      		ldi r24,lo8(70)
 1491 038e 0E94 0000 		call PrintAvailablePort
 1492               	.LVL159:
1798:stk500boot.c  **** #endif
 1493               		.loc 1 1798 0
 1494 0392 87E4      		ldi r24,lo8(71)
 1495 0394 0E94 0000 		call PrintAvailablePort
 1496               	.LVL160:
1802:stk500boot.c  **** #endif
 1497               		.loc 1 1802 0
 1498 0398 88E4      		ldi r24,lo8(72)
 1499 039a 0E94 0000 		call PrintAvailablePort
 1500               	.LVL161:
1810:stk500boot.c  **** #endif
 1501               		.loc 1 1810 0
 1502 039e 8AE4      		ldi r24,lo8(74)
 1503 03a0 0E94 0000 		call PrintAvailablePort
 1504               	.LVL162:
1814:stk500boot.c  **** #endif
 1505               		.loc 1 1814 0
 1506 03a4 8BE4      		ldi r24,lo8(75)
 1507 03a6 0E94 0000 		call PrintAvailablePort
 1508               	.LVL163:
1818:stk500boot.c  **** #endif
 1509               		.loc 1 1818 0
 1510 03aa 8CE4      		ldi r24,lo8(76)
 1511 03ac 0E94 0000 		call PrintAvailablePort
 1512               	.LVL164:
 1513 03b0 00C0      		rjmp .L202
 1514               	.L80:
 1515               	.LBE201:
 1516               	.LBE200:
2058:stk500boot.c  **** 		{
 1517               		.loc 1 2058 0
 1518 03b2 0635      		cpi r16,lo8(86)
 1519 03b4 01F4      		brne .+2
 1520 03b6 00C0      		rjmp .L83
 1521 03b8 0935      		cpi r16,lo8(89)
 1522 03ba 01F4      		brne .+2
 1523 03bc 00C0      		rjmp .L84
 1524 03be 0235      		cpi r16,lo8(82)
 1525 03c0 01F0      		breq .+2
 1526 03c2 00C0      		rjmp .L70
2105:stk500boot.c  **** 				ListAvailablePorts();
2106:stk500boot.c  **** 				break;
2107:stk500boot.c  **** 
2108:stk500boot.c  **** 			case 'Q':
2109:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_Q, 2);
2110:stk500boot.c  **** 				keepGoing	=	false;
2111:stk500boot.c  **** 				break;
2112:stk500boot.c  **** 
2113:stk500boot.c  **** 			case 'R':
2114:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_R, 2);
 1527               		.loc 1 2114 0
 1528 03c4 62E0      		ldi r22,lo8(2)
 1529 03c6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1530 03c8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1531 03ca 0E94 0000 		call PrintFromPROGMEMln_p
 1532               	.LVL165:
2115:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 1533               		.loc 1 2115 0
 1534 03ce 4091 0000 		lds r20,gRamIndex
 1535 03d2 5091 0000 		lds r21,gRamIndex+1
 1536 03d6 6091 0000 		lds r22,gRamIndex+2
 1537 03da 7091 0000 		lds r23,gRamIndex+3
 1538 03de 82E0      		ldi r24,lo8(2)
 1539 03e0 0E94 0000 		call DumpHex.constprop.0
 1540               	.LVL166:
2116:stk500boot.c  **** 				gRamIndex	+=	256;
 1541               		.loc 1 2116 0
 1542 03e4 8091 0000 		lds r24,gRamIndex
 1543 03e8 9091 0000 		lds r25,gRamIndex+1
 1544 03ec A091 0000 		lds r26,gRamIndex+2
 1545 03f0 B091 0000 		lds r27,gRamIndex+3
 1546 03f4 9F5F      		subi r25,-1
 1547 03f6 AF4F      		sbci r26,-1
 1548 03f8 BF4F      		sbci r27,-1
 1549 03fa 8093 0000 		sts gRamIndex,r24
 1550 03fe 9093 0000 		sts gRamIndex+1,r25
 1551 0402 A093 0000 		sts gRamIndex+2,r26
 1552 0406 B093 0000 		sts gRamIndex+3,r27
 1553 040a 00C0      		rjmp .L202
 1554               	.L75:
2061:stk500boot.c  **** 				gFlashIndex		=	0;
 1555               		.loc 1 2061 0
 1556 040c 62E0      		ldi r22,lo8(2)
 1557 040e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1558 0410 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1559 0412 0E94 0000 		call PrintFromPROGMEMln_p
 1560               	.LVL167:
2062:stk500boot.c  **** 				gRamIndex		=	0;
 1561               		.loc 1 2062 0
 1562 0416 1092 0000 		sts gFlashIndex,__zero_reg__
 1563 041a 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1564 041e 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1565 0422 1092 0000 		sts gFlashIndex+3,__zero_reg__
2063:stk500boot.c  **** 				gEepromIndex	=	0;
 1566               		.loc 1 2063 0
 1567 0426 1092 0000 		sts gRamIndex,__zero_reg__
 1568 042a 1092 0000 		sts gRamIndex+1,__zero_reg__
 1569 042e 1092 0000 		sts gRamIndex+2,__zero_reg__
 1570 0432 1092 0000 		sts gRamIndex+3,__zero_reg__
 1571 0436 00C0      		rjmp .L283
 1572               	.L73:
2073:stk500boot.c  **** 				EEPROMtest();
 1573               		.loc 1 2073 0
 1574 0438 62E0      		ldi r22,lo8(2)
 1575 043a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1576 043c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1577 043e 0E94 0000 		call PrintFromPROGMEMln_p
 1578               	.LVL168:
 1579               	.LBB202:
 1580               	.LBB203:
1568:stk500boot.c  **** 	PrintNewLine();
 1581               		.loc 1 1568 0
 1582 0442 60E0      		ldi r22,0
 1583 0444 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1584 0446 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1585 0448 0E94 0000 		call PrintFromPROGMEMln_p
 1586               	.LVL169:
1569:stk500boot.c  **** 	ii			=	0;
 1587               		.loc 1 1569 0
 1588 044c 0E94 0000 		call PrintNewLine
 1589               	.LVL170:
1570:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1590               		.loc 1 1570 0
 1591 0450 E12C      		mov r14,__zero_reg__
 1592 0452 F12C      		mov r15,__zero_reg__
 1593               	.LVL171:
 1594               	.L87:
 1595               	.LBB204:
1572:stk500boot.c  **** #else
 1596               		.loc 1 1572 0
 1597 0454 C701      		movw r24,r14
 1598 0456 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1599 0458 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1600 045a 092E      		mov __tmp_reg__,r25
 1601 045c 000C      		lsl r0
 1602 045e AA0B      		sbc r26,r26
 1603 0460 BB0B      		sbc r27,r27
 1604               	.LVL172:
 1605               	/* #APP */
 1606               	 ;  1572 "stk500boot.c" 1
 1607 0462 ABBF      		out 59, r26
 1608 0464 FC01      		movw r30, r24
 1609 0466 0791      		elpm r16, Z+
 1610               		
 1611               	 ;  0 "" 2
 1612               	.LVL173:
 1613               	/* #NOAPP */
 1614               	.LBE204:
 1615 0468 0A32      		cpi r16,lo8(42)
 1616 046a 01F0      		breq .L90
 1617 046c E114      		cp r14,__zero_reg__
 1618 046e 62E0      		ldi r22,2
 1619 0470 F606      		cpc r15,r22
 1620 0472 01F0      		breq .L90
1577:stk500boot.c  **** 		if (theChar == 0)
 1621               		.loc 1 1577 0
 1622 0474 602F      		mov r22,r16
 1623 0476 C701      		movw r24,r14
 1624               	.LVL174:
 1625 0478 0E94 0000 		call eeprom_write_byte
 1626               	.LVL175:
1578:stk500boot.c  **** 		{
 1627               		.loc 1 1578 0
 1628 047c 0111      		cpse r16,__zero_reg__
 1629 047e 00C0      		rjmp .L88
1580:stk500boot.c  **** 		}
 1630               		.loc 1 1580 0
 1631 0480 60E0      		ldi r22,0
 1632 0482 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1633 0484 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1634 0486 0E94 0000 		call PrintFromPROGMEM_p
 1635               	.LVL176:
 1636 048a 00C0      		rjmp .L89
 1637               	.L88:
1584:stk500boot.c  **** 		}
 1638               		.loc 1 1584 0
 1639 048c 802F      		mov r24,r16
 1640 048e 0E94 0000 		call sendchar
 1641               	.LVL177:
 1642               	.L89:
1586:stk500boot.c  **** 	}
 1643               		.loc 1 1586 0
 1644 0492 5FEF      		ldi r21,-1
 1645 0494 E51A      		sub r14,r21
 1646 0496 F50A      		sbc r15,r21
 1647               	.LVL178:
 1648 0498 00C0      		rjmp .L87
 1649               	.LVL179:
 1650               	.L90:
1590:stk500boot.c  **** 	PrintNewLine();
 1651               		.loc 1 1590 0
 1652 049a 0E94 0000 		call PrintNewLine
 1653               	.LVL180:
1591:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_ReadingEEprom, 0);
 1654               		.loc 1 1591 0
 1655 049e 0E94 0000 		call PrintNewLine
 1656               	.LVL181:
1592:stk500boot.c  **** 	PrintNewLine();
 1657               		.loc 1 1592 0
 1658 04a2 60E0      		ldi r22,0
 1659 04a4 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1660 04a6 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1661 04a8 0E94 0000 		call PrintFromPROGMEMln_p
 1662               	.LVL182:
1593:stk500boot.c  **** 	errorCount	=	0;
 1663               		.loc 1 1593 0
 1664 04ac 0E94 0000 		call PrintNewLine
 1665               	.LVL183:
1594:stk500boot.c  **** 	ii			=	0;
 1666               		.loc 1 1594 0
 1667 04b0 C12C      		mov r12,__zero_reg__
 1668 04b2 D12C      		mov r13,__zero_reg__
1595:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1669               		.loc 1 1595 0
 1670 04b4 E12C      		mov r14,__zero_reg__
 1671 04b6 F12C      		mov r15,__zero_reg__
 1672               	.LVL184:
 1673               	.L92:
 1674               	.LBB205:
1597:stk500boot.c  **** #else
 1675               		.loc 1 1597 0
 1676 04b8 C701      		movw r24,r14
 1677 04ba 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1678 04bc 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1679 04be 092E      		mov __tmp_reg__,r25
 1680 04c0 000C      		lsl r0
 1681 04c2 AA0B      		sbc r26,r26
 1682 04c4 BB0B      		sbc r27,r27
 1683               	.LVL185:
 1684               	/* #APP */
 1685               	 ;  1597 "stk500boot.c" 1
 1686 04c6 ABBF      		out 59, r26
 1687 04c8 FC01      		movw r30, r24
 1688 04ca 0791      		elpm r16, Z+
 1689               		
 1690               	 ;  0 "" 2
 1691               	.LVL186:
 1692               	/* #NOAPP */
 1693               	.LBE205:
 1694 04cc 0A32      		cpi r16,lo8(42)
 1695 04ce 01F0      		breq .L96
 1696 04d0 E114      		cp r14,__zero_reg__
 1697 04d2 92E0      		ldi r25,2
 1698 04d4 F906      		cpc r15,r25
 1699 04d6 01F0      		breq .L96
1602:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1700               		.loc 1 1602 0
 1701 04d8 C701      		movw r24,r14
 1702               	.LVL187:
 1703 04da 0E94 0000 		call eeprom_read_byte
 1704               	.LVL188:
 1705 04de 782E      		mov r7,r24
 1706               	.LVL189:
1603:stk500boot.c  **** 		{
 1707               		.loc 1 1603 0
 1708 04e0 8111      		cpse r24,__zero_reg__
 1709 04e2 00C0      		rjmp .L93
1605:stk500boot.c  **** 		}
 1710               		.loc 1 1605 0
 1711 04e4 60E0      		ldi r22,0
 1712 04e6 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1713 04e8 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1714 04ea 0E94 0000 		call PrintFromPROGMEM_p
 1715               	.LVL190:
 1716 04ee 00C0      		rjmp .L94
 1717               	.L93:
1609:stk500boot.c  **** 		}
 1718               		.loc 1 1609 0
 1719 04f0 0E94 0000 		call sendchar
 1720               	.LVL191:
 1721               	.L94:
1611:stk500boot.c  **** 		{
 1722               		.loc 1 1611 0
 1723 04f4 7016      		cp r7,r16
 1724 04f6 01F0      		breq .L95
1613:stk500boot.c  **** 		}
 1725               		.loc 1 1613 0
 1726 04f8 7FEF      		ldi r23,-1
 1727 04fa C71A      		sub r12,r23
 1728 04fc D70A      		sbc r13,r23
 1729               	.LVL192:
 1730               	.L95:
1615:stk500boot.c  **** 	}
 1731               		.loc 1 1615 0
 1732 04fe 8FEF      		ldi r24,-1
 1733 0500 E81A      		sub r14,r24
 1734 0502 F80A      		sbc r15,r24
 1735               	.LVL193:
 1736 0504 00C0      		rjmp .L92
 1737               	.LVL194:
 1738               	.L96:
1617:stk500boot.c  **** 	PrintNewLine();
 1739               		.loc 1 1617 0
 1740 0506 0E94 0000 		call PrintNewLine
 1741               	.LVL195:
1618:stk500boot.c  **** 	PrintFromPROGMEM_p(gTextMsg_EEPROMerrorCnt, 0);
 1742               		.loc 1 1618 0
 1743 050a 0E94 0000 		call PrintNewLine
 1744               	.LVL196:
1619:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1745               		.loc 1 1619 0
 1746 050e 60E0      		ldi r22,0
 1747 0510 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1748 0512 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1749 0514 0E94 0000 		call PrintFromPROGMEM_p
 1750               	.LVL197:
1620:stk500boot.c  **** 	PrintNewLine();
 1751               		.loc 1 1620 0
 1752 0518 61E0      		ldi r22,lo8(1)
 1753 051a 70E0      		ldi r23,0
 1754 051c C601      		movw r24,r12
 1755 051e 0E94 0000 		call PrintDecInt
 1756               	.LVL198:
1621:stk500boot.c  **** 	PrintNewLine();
 1757               		.loc 1 1621 0
 1758 0522 0E94 0000 		call PrintNewLine
 1759               	.LVL199:
1622:stk500boot.c  **** 
 1760               		.loc 1 1622 0
 1761 0526 0E94 0000 		call PrintNewLine
 1762               	.LVL200:
 1763               	.L283:
1624:stk500boot.c  **** 
 1764               		.loc 1 1624 0
 1765 052a 1092 0000 		sts gEepromIndex,__zero_reg__
 1766 052e 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1767 0532 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1768 0536 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1769 053a 00C0      		rjmp .L202
 1770               	.LVL201:
 1771               	.L77:
 1772               	.LBE203:
 1773               	.LBE202:
2078:stk500boot.c  **** 				BlinkLED();
 1774               		.loc 1 2078 0
 1775 053c 62E0      		ldi r22,lo8(2)
 1776 053e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1777 0540 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1778 0542 0E94 0000 		call PrintFromPROGMEMln_p
 1779               	.LVL202:
 1780               	.LBB206:
 1781               	.LBB207:
1469:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 1782               		.loc 1 1469 0
 1783 0546 279A      		sbi 0x4,7
1470:stk500boot.c  **** 
 1784               		.loc 1 1470 0
 1785 0548 2F9A      		sbi 0x5,7
 1786               	.L98:
 1787               	.LBB208:
 1788               	.LBB209:
 480:stk500boot.c  **** }
 1789               		.loc 1 480 0
 1790 054a 8091 C800 		lds r24,200
 1791               	.LBE209:
 1792               	.LBE208:
1472:stk500boot.c  **** 	{
 1793               		.loc 1 1472 0
 1794 054e 87FD      		sbrc r24,7
 1795 0550 00C0      		rjmp .L125
1474:stk500boot.c  **** 		delay_ms(100);
 1796               		.loc 1 1474 0
 1797 0552 2F98      		cbi 0x5,7
1475:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 1798               		.loc 1 1475 0
 1799 0554 84E6      		ldi r24,lo8(100)
 1800 0556 90E0      		ldi r25,0
 1801 0558 0E94 0000 		call delay_ms
 1802               	.LVL203:
1476:stk500boot.c  **** 		delay_ms(100);
 1803               		.loc 1 1476 0
 1804 055c 2F9A      		sbi 0x5,7
1477:stk500boot.c  **** 	}
 1805               		.loc 1 1477 0
 1806 055e 84E6      		ldi r24,lo8(100)
 1807 0560 90E0      		ldi r25,0
 1808 0562 0E94 0000 		call delay_ms
 1809               	.LVL204:
 1810 0566 00C0      		rjmp .L98
 1811               	.LVL205:
 1812               	.L292:
 1813               	.LBE207:
 1814               	.LBE206:
 1815               	.LBB211:
 1816               	.LBB190:
1849:stk500boot.c  **** 				break;
 1817               		.loc 1 1849 0
 1818 0568 12B8      		out 0x2,__zero_reg__
 1819               	.LVL206:
 1820               	.L125:
 1821               	.LBE190:
 1822               	.LBE211:
 1823               	.LBB212:
 1824               	.LBB210:
1479:stk500boot.c  **** }
 1825               		.loc 1 1479 0
 1826 056a 0E94 0000 		call recchar
 1827               	.LVL207:
 1828 056e 00C0      		rjmp .L202
 1829               	.LVL208:
 1830               	.L78:
 1831               	.LBE210:
 1832               	.LBE212:
2083:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1833               		.loc 1 2083 0
 1834 0570 62E0      		ldi r22,lo8(2)
 1835 0572 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1836 0574 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1837 0576 0E94 0000 		call PrintFromPROGMEMln_p
 1838               	.LVL209:
2084:stk500boot.c  **** 				gEepromIndex	+=	256;
 1839               		.loc 1 2084 0
 1840 057a 4091 0000 		lds r20,gEepromIndex
 1841 057e 5091 0000 		lds r21,gEepromIndex+1
 1842 0582 6091 0000 		lds r22,gEepromIndex+2
 1843 0586 7091 0000 		lds r23,gEepromIndex+3
 1844 058a 81E0      		ldi r24,lo8(1)
 1845 058c 0E94 0000 		call DumpHex.constprop.0
 1846               	.LVL210:
2085:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1847               		.loc 1 2085 0
 1848 0590 8091 0000 		lds r24,gEepromIndex
 1849 0594 9091 0000 		lds r25,gEepromIndex+1
 1850 0598 A091 0000 		lds r26,gEepromIndex+2
 1851 059c B091 0000 		lds r27,gEepromIndex+3
 1852 05a0 9F5F      		subi r25,-1
 1853 05a2 AF4F      		sbci r26,-1
 1854 05a4 BF4F      		sbci r27,-1
 1855 05a6 8093 0000 		sts gEepromIndex,r24
 1856 05aa 9093 0000 		sts gEepromIndex+1,r25
 1857 05ae A093 0000 		sts gEepromIndex+2,r26
 1858 05b2 B093 0000 		sts gEepromIndex+3,r27
2086:stk500boot.c  **** 				{
 1859               		.loc 1 2086 0
 1860 05b6 8115      		cp r24,__zero_reg__
 1861 05b8 9041      		sbci r25,16
 1862 05ba A105      		cpc r26,__zero_reg__
 1863 05bc B105      		cpc r27,__zero_reg__
 1864 05be 00F4      		brsh .+2
 1865 05c0 00C0      		rjmp .L202
 1866 05c2 00C0      		rjmp .L283
 1867               	.L71:
2093:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 1868               		.loc 1 2093 0
 1869 05c4 62E0      		ldi r22,lo8(2)
 1870 05c6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1871 05c8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1872 05ca 0E94 0000 		call PrintFromPROGMEMln_p
 1873               	.LVL211:
2094:stk500boot.c  **** 				gFlashIndex	+=	256;
 1874               		.loc 1 2094 0
 1875 05ce 4091 0000 		lds r20,gFlashIndex
 1876 05d2 5091 0000 		lds r21,gFlashIndex+1
 1877 05d6 6091 0000 		lds r22,gFlashIndex+2
 1878 05da 7091 0000 		lds r23,gFlashIndex+3
 1879 05de 80E0      		ldi r24,0
 1880 05e0 0E94 0000 		call DumpHex.constprop.0
 1881               	.LVL212:
2095:stk500boot.c  **** 				break;
 1882               		.loc 1 2095 0
 1883 05e4 8091 0000 		lds r24,gFlashIndex
 1884 05e8 9091 0000 		lds r25,gFlashIndex+1
 1885 05ec A091 0000 		lds r26,gFlashIndex+2
 1886 05f0 B091 0000 		lds r27,gFlashIndex+3
 1887 05f4 9F5F      		subi r25,-1
 1888 05f6 AF4F      		sbci r26,-1
 1889 05f8 BF4F      		sbci r27,-1
 1890 05fa 8093 0000 		sts gFlashIndex,r24
 1891 05fe 9093 0000 		sts gFlashIndex+1,r25
 1892 0602 A093 0000 		sts gFlashIndex+2,r26
 1893 0606 B093 0000 		sts gFlashIndex+3,r27
 1894 060a 00C0      		rjmp .L202
 1895               	.L81:
2099:stk500boot.c  **** 				PrintHelp();
 1896               		.loc 1 2099 0
 1897 060c 62E0      		ldi r22,lo8(2)
 1898 060e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1899 0610 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1900 0612 0E94 0000 		call PrintFromPROGMEMln_p
 1901               	.LVL213:
 1902               	.LBB213:
 1903               	.LBB214:
2005:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_QM, 0);
 1904               		.loc 1 2005 0
 1905 0616 60E0      		ldi r22,0
 1906 0618 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1907 061a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1908 061c 0E94 0000 		call PrintFromPROGMEMln_p
 1909               	.LVL214:
2006:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_AT, 0);
 1910               		.loc 1 2006 0
 1911 0620 60E0      		ldi r22,0
 1912 0622 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1913 0624 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1914 0626 0E94 0000 		call PrintFromPROGMEMln_p
 1915               	.LVL215:
2007:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_B, 0);
 1916               		.loc 1 2007 0
 1917 062a 60E0      		ldi r22,0
 1918 062c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1919 062e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1920 0630 0E94 0000 		call PrintFromPROGMEMln_p
 1921               	.LVL216:
2008:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_E, 0);
 1922               		.loc 1 2008 0
 1923 0634 60E0      		ldi r22,0
 1924 0636 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1925 0638 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1926 063a 0E94 0000 		call PrintFromPROGMEMln_p
 1927               	.LVL217:
2009:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_F, 0);
 1928               		.loc 1 2009 0
 1929 063e 60E0      		ldi r22,0
 1930 0640 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1931 0642 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1932 0644 0E94 0000 		call PrintFromPROGMEMln_p
 1933               	.LVL218:
2010:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_H, 0);
 1934               		.loc 1 2010 0
 1935 0648 60E0      		ldi r22,0
 1936 064a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1937 064c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1938 064e 0E94 0000 		call PrintFromPROGMEMln_p
 1939               	.LVL219:
2011:stk500boot.c  **** 
 1940               		.loc 1 2011 0
 1941 0652 60E0      		ldi r22,0
 1942 0654 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1943 0656 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1944 0658 0E94 0000 		call PrintFromPROGMEMln_p
 1945               	.LVL220:
2013:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_Q, 0);
 1946               		.loc 1 2013 0
 1947 065c 60E0      		ldi r22,0
 1948 065e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1949 0660 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1950 0662 0E94 0000 		call PrintFromPROGMEMln_p
 1951               	.LVL221:
2014:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_R, 0);
 1952               		.loc 1 2014 0
 1953 0666 60E0      		ldi r22,0
 1954 0668 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1955 066a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1956 066c 0E94 0000 		call PrintFromPROGMEMln_p
 1957               	.LVL222:
2015:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_V, 0);
 1958               		.loc 1 2015 0
 1959 0670 60E0      		ldi r22,0
 1960 0672 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1961 0674 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1962 0676 0E94 0000 		call PrintFromPROGMEMln_p
 1963               	.LVL223:
2016:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_Y, 0);
 1964               		.loc 1 2016 0
 1965 067a 60E0      		ldi r22,0
 1966 067c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1967 067e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1968 0680 0E94 0000 		call PrintFromPROGMEMln_p
 1969               	.LVL224:
2017:stk500boot.c  **** }
 1970               		.loc 1 2017 0
 1971 0684 60E0      		ldi r22,0
 1972 0686 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 1973 0688 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 1974 068a 00C0      		rjmp .L282
 1975               	.L79:
 1976               	.LBE214:
 1977               	.LBE213:
2109:stk500boot.c  **** 				keepGoing	=	false;
 1978               		.loc 1 2109 0
 1979 068c 62E0      		ldi r22,lo8(2)
 1980 068e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1981 0690 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1982 0692 0E94 0000 		call PrintFromPROGMEMln_p
 1983               	.LVL225:
 1984               	.LBE165:
 1985               	.LBE164:
 698:stk500boot.c  **** 						isLeave			=	1;
 1986               		.loc 1 698 0
 1987 0696 E12C      		mov r14,__zero_reg__
 1988 0698 F12C      		mov r15,__zero_reg__
 699:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 1989               		.loc 1 699 0
 1990 069a 6624      		clr r6
 1991 069c 6394      		inc r6
 1992 069e 00C0      		rjmp .L101
 1993               	.LVL226:
 1994               	.L83:
 1995               	.LBB223:
 1996               	.LBB222:
2117:stk500boot.c  **** 				break;
2118:stk500boot.c  **** 
2119:stk500boot.c  **** 			case 'V':
2120:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_V, 2);
 1997               		.loc 1 2120 0
 1998 06a0 62E0      		ldi r22,lo8(2)
 1999 06a2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 2000 06a4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 2001 06a6 0E94 0000 		call PrintFromPROGMEMln_p
 2002               	.LVL227:
 2003               	.LBB215:
 2004               	.LBB216:
1660:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_VECTOR_HEADER, 0);
 2005               		.loc 1 1660 0
 2006 06aa 60E0      		ldi r22,0
 2007 06ac 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 2008 06ae 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 2009 06b0 0E94 0000 		call PrintFromPROGMEMln_p
 2010               	.LVL228:
1661:stk500boot.c  **** 	//					 V#   ADDR   op code
 2011               		.loc 1 1661 0
 2012 06b4 60E0      		ldi r22,0
 2013 06b6 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 2014 06b8 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 2015 06ba 0E94 0000 		call PrintFromPROGMEMln_p
 2016               	.LVL229:
1659:stk500boot.c  **** 	PrintFromPROGMEMln_p(gTextMsg_CPU_Name, 0);
 2017               		.loc 1 1659 0
 2018 06be 212C      		mov r2,__zero_reg__
 2019 06c0 312C      		mov r3,__zero_reg__
1658:stk500boot.c  **** 	vectorIndex		=	0;
 2020               		.loc 1 1658 0
 2021 06c2 C25E      		subi r28,lo8(-286)
 2022 06c4 DE4F      		sbci r29,hi8(-286)
 2023 06c6 1882      		st Y,__zero_reg__
 2024 06c8 1982      		std Y+1,__zero_reg__
 2025 06ca 1A82      		std Y+2,__zero_reg__
 2026 06cc 1B82      		std Y+3,__zero_reg__
 2027 06ce CE51      		subi r28,lo8(286)
 2028 06d0 D140      		sbci r29,hi8(286)
 2029               	.LVL230:
 2030               	.L105:
1666:stk500boot.c  **** 		//					 01 - 0000 = 12 34
 2031               		.loc 1 1666 0
 2032 06d2 C25E      		subi r28,lo8(-286)
 2033 06d4 DE4F      		sbci r29,hi8(-286)
 2034 06d6 2881      		ld r18,Y
 2035 06d8 3981      		ldd r19,Y+1
 2036 06da 4A81      		ldd r20,Y+2
 2037 06dc 5B81      		ldd r21,Y+3
 2038 06de CE51      		subi r28,lo8(286)
 2039 06e0 D140      		sbci r29,hi8(286)
 2040 06e2 5695      		lsr r21
 2041 06e4 4795      		ror r20
 2042 06e6 3795      		ror r19
 2043 06e8 2795      		ror r18
 2044 06ea C55D      		subi r28,lo8(-299)
 2045 06ec DE4F      		sbci r29,hi8(-299)
 2046 06ee 2883      		st Y,r18
 2047 06f0 3983      		std Y+1,r19
 2048 06f2 4A83      		std Y+2,r20
 2049 06f4 5B83      		std Y+3,r21
 2050 06f6 CB52      		subi r28,lo8(299)
 2051 06f8 D140      		sbci r29,hi8(299)
 2052               	.LVL231:
1668:stk500boot.c  **** 		sendchar(0x20);
 2053               		.loc 1 1668 0
 2054 06fa 3FEF      		ldi r19,-1
 2055 06fc 231A      		sub r2,r19
 2056 06fe 330A      		sbc r3,r19
 2057               	.LVL232:
 2058 0700 62E0      		ldi r22,lo8(2)
 2059 0702 70E0      		ldi r23,0
 2060 0704 C101      		movw r24,r2
 2061 0706 0E94 0000 		call PrintDecInt
 2062               	.LVL233:
1669:stk500boot.c  **** 		sendchar('-');
 2063               		.loc 1 1669 0
 2064 070a 80E2      		ldi r24,lo8(32)
 2065 070c 0E94 0000 		call sendchar
 2066               	.LVL234:
1670:stk500boot.c  **** 		sendchar(0x20);
 2067               		.loc 1 1670 0
 2068 0710 8DE2      		ldi r24,lo8(45)
 2069 0712 0E94 0000 		call sendchar
 2070               	.LVL235:
1671:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2071               		.loc 1 1671 0
 2072 0716 80E2      		ldi r24,lo8(32)
 2073 0718 0E94 0000 		call sendchar
 2074               	.LVL236:
1672:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2075               		.loc 1 1672 0
 2076 071c 80E0      		ldi r24,0
 2077 071e 0E94 0000 		call PrintHexByte
 2078               	.LVL237:
1673:stk500boot.c  **** 		sendchar(0x20);
 2079               		.loc 1 1673 0
 2080 0722 C55D      		subi r28,lo8(-299)
 2081 0724 DE4F      		sbci r29,hi8(-299)
 2082 0726 8881      		ld r24,Y
 2083 0728 CB52      		subi r28,lo8(299)
 2084 072a D140      		sbci r29,hi8(299)
 2085 072c 0E94 0000 		call PrintHexByte
 2086               	.LVL238:
1674:stk500boot.c  **** 		sendchar('=');
 2087               		.loc 1 1674 0
 2088 0730 80E2      		ldi r24,lo8(32)
 2089 0732 0E94 0000 		call sendchar
 2090               	.LVL239:
1675:stk500boot.c  **** 		sendchar(0x20);
 2091               		.loc 1 1675 0
 2092 0736 8DE3      		ldi r24,lo8(61)
 2093 0738 0E94 0000 		call sendchar
 2094               	.LVL240:
1676:stk500boot.c  **** 
 2095               		.loc 1 1676 0
 2096 073c 80E2      		ldi r24,lo8(32)
 2097 073e 0E94 0000 		call sendchar
 2098               	.LVL241:
 2099               	.LBB217:
1681:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2100               		.loc 1 1681 0
 2101 0742 C25E      		subi r28,lo8(-286)
 2102 0744 DE4F      		sbci r29,hi8(-286)
 2103 0746 4881      		ld r20,Y
 2104 0748 5981      		ldd r21,Y+1
 2105 074a 6A81      		ldd r22,Y+2
 2106 074c 7B81      		ldd r23,Y+3
 2107 074e CE51      		subi r28,lo8(286)
 2108 0750 D140      		sbci r29,hi8(286)
 2109               	/* #APP */
 2110               	 ;  1681 "stk500boot.c" 1
 2111 0752 6BBF      		out 59, r22
 2112 0754 FA01      		movw r30, r20
 2113 0756 0791      		elpm r16, Z+
 2114               		
 2115               	 ;  0 "" 2
 2116               	.LVL242:
 2117               	/* #NOAPP */
 2118               	.LBE217:
 2119               	.LBB218:
1682:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2120               		.loc 1 1682 0
 2121 0758 6A01      		movw r12,r20
 2122 075a 7B01      		movw r14,r22
 2123 075c 5FEF      		ldi r21,-1
 2124 075e C51A      		sub r12,r21
 2125 0760 D50A      		sbc r13,r21
 2126 0762 E50A      		sbc r14,r21
 2127 0764 F50A      		sbc r15,r21
 2128               	.LVL243:
 2129               	/* #APP */
 2130               	 ;  1682 "stk500boot.c" 1
 2131 0766 EBBE      		out 59, r14
 2132 0768 F601      		movw r30, r12
 2133 076a E790      		elpm r14, Z+
 2134               		
 2135               	 ;  0 "" 2
 2136               	.LVL244:
 2137               	/* #NOAPP */
 2138               	.LBE218:
 2139               	.LBB219:
1683:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2140               		.loc 1 1683 0
 2141 076c C25E      		subi r28,lo8(-286)
 2142 076e DE4F      		sbci r29,hi8(-286)
 2143 0770 8881      		ld r24,Y
 2144 0772 9981      		ldd r25,Y+1
 2145 0774 AA81      		ldd r26,Y+2
 2146 0776 BB81      		ldd r27,Y+3
 2147 0778 CE51      		subi r28,lo8(286)
 2148 077a D140      		sbci r29,hi8(286)
 2149 077c 0296      		adiw r24,2
 2150 077e A11D      		adc r26,__zero_reg__
 2151 0780 B11D      		adc r27,__zero_reg__
 2152               	.LVL245:
 2153               	/* #APP */
 2154               	 ;  1683 "stk500boot.c" 1
 2155 0782 ABBF      		out 59, r26
 2156 0784 FC01      		movw r30, r24
 2157 0786 D790      		elpm r13, Z+
 2158               		
 2159               	 ;  0 "" 2
 2160               	.LVL246:
 2161               	/* #NOAPP */
 2162               	.LBE219:
 2163               	.LBB220:
1684:stk500boot.c  **** 	#else
 2164               		.loc 1 1684 0
 2165 0788 C25E      		subi r28,lo8(-286)
 2166 078a DE4F      		sbci r29,hi8(-286)
 2167 078c 8881      		ld r24,Y
 2168 078e 9981      		ldd r25,Y+1
 2169 0790 AA81      		ldd r26,Y+2
 2170 0792 BB81      		ldd r27,Y+3
 2171 0794 CE51      		subi r28,lo8(286)
 2172 0796 D140      		sbci r29,hi8(286)
 2173               	.LVL247:
 2174 0798 0396      		adiw r24,3
 2175 079a A11D      		adc r26,__zero_reg__
 2176 079c B11D      		adc r27,__zero_reg__
 2177               	/* #APP */
 2178               	 ;  1684 "stk500boot.c" 1
 2179 079e ABBF      		out 59, r26
 2180 07a0 FC01      		movw r30, r24
 2181 07a2 F790      		elpm r15, Z+
 2182               		
 2183               	 ;  0 "" 2
 2184               	/* #NOAPP */
 2185 07a4 C25E      		subi r28,lo8(-286)
 2186 07a6 DE4F      		sbci r29,hi8(-286)
 2187 07a8 6881      		ld r22,Y
 2188 07aa 7981      		ldd r23,Y+1
 2189 07ac 8A81      		ldd r24,Y+2
 2190 07ae 9B81      		ldd r25,Y+3
 2191 07b0 CE51      		subi r28,lo8(286)
 2192 07b2 D140      		sbci r29,hi8(286)
 2193 07b4 6C5F      		subi r22,-4
 2194 07b6 7F4F      		sbci r23,-1
 2195 07b8 8F4F      		sbci r24,-1
 2196 07ba 9F4F      		sbci r25,-1
 2197 07bc C25E      		subi r28,lo8(-286)
 2198 07be DE4F      		sbci r29,hi8(-286)
 2199 07c0 6883      		st Y,r22
 2200 07c2 7983      		std Y+1,r23
 2201 07c4 8A83      		std Y+2,r24
 2202 07c6 9B83      		std Y+3,r25
 2203 07c8 CE51      		subi r28,lo8(286)
 2204 07ca D140      		sbci r29,hi8(286)
 2205               	.LVL248:
 2206               	.LBE220:
1691:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2207               		.loc 1 1691 0
 2208 07cc 4E2C      		mov r4,r14
 2209 07ce 512C      		mov r5,__zero_reg__
 2210 07d0 612C      		mov r6,__zero_reg__
 2211 07d2 712C      		mov r7,__zero_reg__
 2212 07d4 762C      		mov r7,r6
 2213 07d6 652C      		mov r6,r5
 2214 07d8 542C      		mov r5,r4
 2215 07da 4424      		clr r4
 2216 07dc 400E      		add r4,r16
 2217 07de 511C      		adc r5,__zero_reg__
 2218 07e0 611C      		adc r6,__zero_reg__
 2219 07e2 711C      		adc r7,__zero_reg__
 2220               	.LVL249:
1695:stk500boot.c  **** 		sendchar(0x20);
 2221               		.loc 1 1695 0
 2222 07e4 8E2D      		mov r24,r14
 2223 07e6 0E94 0000 		call PrintHexByte
 2224               	.LVL250:
1696:stk500boot.c  **** 		PrintHexByte(byte1);
 2225               		.loc 1 1696 0
 2226 07ea 80E2      		ldi r24,lo8(32)
 2227 07ec 0E94 0000 		call sendchar
 2228               	.LVL251:
1697:stk500boot.c  **** 		sendchar(0x20);
 2229               		.loc 1 1697 0
 2230 07f0 802F      		mov r24,r16
 2231 07f2 0E94 0000 		call PrintHexByte
 2232               	.LVL252:
1698:stk500boot.c  **** 		PrintHexByte(byte4);
 2233               		.loc 1 1698 0
 2234 07f6 80E2      		ldi r24,lo8(32)
 2235 07f8 0E94 0000 		call sendchar
 2236               	.LVL253:
1699:stk500boot.c  **** 		sendchar(0x20);
 2237               		.loc 1 1699 0
 2238 07fc 8F2D      		mov r24,r15
 2239 07fe 0E94 0000 		call PrintHexByte
 2240               	.LVL254:
1700:stk500boot.c  **** 		PrintHexByte(byte3);
 2241               		.loc 1 1700 0
 2242 0802 80E2      		ldi r24,lo8(32)
 2243 0804 0E94 0000 		call sendchar
 2244               	.LVL255:
1701:stk500boot.c  **** 		sendchar(0x20);
 2245               		.loc 1 1701 0
 2246 0808 8D2D      		mov r24,r13
 2247 080a 0E94 0000 		call PrintHexByte
 2248               	.LVL256:
1702:stk500boot.c  **** 	
 2249               		.loc 1 1702 0
 2250 080e 80E2      		ldi r24,lo8(32)
 2251 0810 0E94 0000 		call sendchar
 2252               	.LVL257:
1704:stk500boot.c  **** 		{
 2253               		.loc 1 1704 0
 2254 0814 7FEF      		ldi r23,-1
 2255 0816 4716      		cp r4,r23
 2256 0818 5706      		cpc r5,r23
 2257 081a 6104      		cpc r6,__zero_reg__
 2258 081c 7104      		cpc r7,__zero_reg__
 2259 081e 01F4      		brne .L102
1706:stk500boot.c  **** 		}
 2260               		.loc 1 1706 0
 2261 0820 60E0      		ldi r22,0
 2262 0822 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2263 0824 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2264 0826 0E94 0000 		call PrintFromPROGMEM_p
 2265               	.LVL258:
 2266 082a 00C0      		rjmp .L103
 2267               	.L102:
1708:stk500boot.c  **** 		{
 2268               		.loc 1 1708 0
 2269 082c D301      		movw r26,r6
 2270 082e C201      		movw r24,r4
 2271 0830 8827      		clr r24
 2272 0832 907C      		andi r25,192
 2273 0834 AA27      		clr r26
 2274 0836 BB27      		clr r27
 2275 0838 8115      		cp r24,__zero_reg__
 2276 083a 904C      		sbci r25,-64
 2277 083c A105      		cpc r26,__zero_reg__
 2278 083e B105      		cpc r27,__zero_reg__
 2279 0840 01F4      		brne .L104
1711:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2280               		.loc 1 1711 0
 2281 0842 7301      		movw r14,r6
 2282 0844 6201      		movw r12,r4
 2283               	.LVL259:
 2284 0846 FFE3      		ldi r31,63
 2285 0848 DF22      		and r13,r31
 2286 084a EE24      		clr r14
 2287 084c FF24      		clr r15
 2288               	.LVL260:
1712:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2289               		.loc 1 1712 0
 2290 084e C55D      		subi r28,lo8(-299)
 2291 0850 DE4F      		sbci r29,hi8(-299)
 2292 0852 4880      		ld r4,Y
 2293 0854 5980      		ldd r5,Y+1
 2294 0856 6A80      		ldd r6,Y+2
 2295 0858 7B80      		ldd r7,Y+3
 2296 085a CB52      		subi r28,lo8(299)
 2297 085c D140      		sbci r29,hi8(299)
 2298               	.LVL261:
 2299 085e 4C0C      		add r4,r12
 2300 0860 5D1C      		adc r5,r13
 2301 0862 6E1C      		adc r6,r14
 2302 0864 7F1C      		adc r7,r15
 2303               	.LVL262:
1713:stk500boot.c  **** 
 2304               		.loc 1 1713 0
 2305 0866 440C      		lsl r4
 2306 0868 551C      		rol r5
 2307 086a 661C      		rol r6
 2308 086c 771C      		rol r7
 2309               	.LVL263:
1715:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
 2310               		.loc 1 1715 0
 2311 086e 60E0      		ldi r22,0
 2312 0870 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2313 0872 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2314 0874 0E94 0000 		call PrintFromPROGMEM_p
 2315               	.LVL264:
1716:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
 2316               		.loc 1 1716 0
 2317 0878 8D2D      		mov r24,r13
 2318 087a 0E94 0000 		call PrintHexByte
 2319               	.LVL265:
1717:stk500boot.c  **** 			sendchar(0x20);
 2320               		.loc 1 1717 0
 2321 087e 8C2D      		mov r24,r12
 2322 0880 0E94 0000 		call PrintHexByte
 2323               	.LVL266:
1718:stk500boot.c  **** 			sendchar('>');
 2324               		.loc 1 1718 0
 2325 0884 80E2      		ldi r24,lo8(32)
 2326 0886 0E94 0000 		call sendchar
 2327               	.LVL267:
1719:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2328               		.loc 1 1719 0
 2329 088a 8EE3      		ldi r24,lo8(62)
 2330 088c 0E94 0000 		call sendchar
 2331               	.LVL268:
1720:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2332               		.loc 1 1720 0
 2333 0890 80E0      		ldi r24,0
 2334 0892 00C0      		rjmp .L284
 2335               	.LVL269:
 2336               	.L104:
1725:stk500boot.c  **** 		{
 2337               		.loc 1 1725 0
 2338 0894 2EE0      		ldi r18,14
 2339 0896 4222      		and r4,r18
 2340 0898 E894      		clt
 2341 089a 50F8      		bld r5,0
 2342 089c 6624      		clr r6
 2343 089e 7724      		clr r7
 2344               	.LVL270:
 2345 08a0 3CE0      		ldi r19,12
 2346 08a2 4316      		cp r4,r19
 2347 08a4 34E9      		ldi r19,-108
 2348 08a6 5306      		cpc r5,r19
 2349 08a8 6104      		cpc r6,__zero_reg__
 2350 08aa 7104      		cpc r7,__zero_reg__
 2351 08ac 01F0      		breq .+2
 2352 08ae 00C0      		rjmp .L103
1728:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2353               		.loc 1 1728 0
 2354 08b0 402F      		mov r20,r16
 2355 08b2 4170      		andi r20,lo8(1)
 2356 08b4 442E      		mov r4,r20
 2357 08b6 512C      		mov r5,__zero_reg__
 2358 08b8 612C      		mov r6,__zero_reg__
 2359 08ba 712C      		mov r7,__zero_reg__
 2360 08bc B201      		movw r22,r4
 2361 08be 5527      		clr r21
 2362 08c0 4427      		clr r20
 2363 08c2 8F2D      		mov r24,r15
 2364 08c4 90E0      		ldi r25,0
 2365 08c6 A0E0      		ldi r26,0
 2366 08c8 B0E0      		ldi r27,0
 2367 08ca BA2F      		mov r27,r26
 2368 08cc A92F      		mov r26,r25
 2369 08ce 982F      		mov r25,r24
 2370 08d0 8827      		clr r24
 2371 08d2 8D0D      		add r24,r13
 2372 08d4 911D      		adc r25,__zero_reg__
 2373 08d6 A11D      		adc r26,__zero_reg__
 2374 08d8 B11D      		adc r27,__zero_reg__
 2375 08da 2A01      		movw r4,r20
 2376 08dc 3B01      		movw r6,r22
 2377 08de 480E      		add r4,r24
 2378 08e0 591E      		adc r5,r25
 2379 08e2 6A1E      		adc r6,r26
 2380 08e4 7B1E      		adc r7,r27
 2381 08e6 802F      		mov r24,r16
 2382 08e8 807F      		andi r24,lo8(-16)
 2383 08ea 90E0      		ldi r25,0
 2384 08ec A0E0      		ldi r26,0
 2385 08ee B0E0      		ldi r27,0
 2386 08f0 AC01      		movw r20,r24
 2387 08f2 BD01      		movw r22,r26
 2388 08f4 31E1      		ldi r19,17
 2389               		1:
 2390 08f6 440F      		lsl r20
 2391 08f8 551F      		rol r21
 2392 08fa 661F      		rol r22
 2393 08fc 771F      		rol r23
 2394 08fe 3A95      		dec r19
 2395 0900 01F4      		brne 1b
 2396 0902 D301      		movw r26,r6
 2397 0904 C201      		movw r24,r4
 2398 0906 840F      		add r24,r20
 2399 0908 951F      		adc r25,r21
 2400 090a A61F      		adc r26,r22
 2401 090c B71F      		adc r27,r23
 2402 090e 2E2D      		mov r18,r14
 2403 0910 2170      		andi r18,lo8(1)
 2404 0912 C22E      		mov r12,r18
 2405               	.LVL271:
 2406 0914 D12C      		mov r13,__zero_reg__
 2407               	.LVL272:
 2408 0916 E12C      		mov r14,__zero_reg__
 2409 0918 F12C      		mov r15,__zero_reg__
 2410               	.LVL273:
 2411 091a 45E1      		ldi r20,21
 2412               		1:
 2413 091c CC0C      		lsl r12
 2414 091e DD1C      		rol r13
 2415 0920 EE1C      		rol r14
 2416 0922 FF1C      		rol r15
 2417 0924 4A95      		dec r20
 2418 0926 01F4      		brne 1b
 2419 0928 C80E      		add r12,r24
 2420 092a D91E      		adc r13,r25
 2421 092c EA1E      		adc r14,r26
 2422 092e FB1E      		adc r15,r27
 2423               	.LVL274:
1733:stk500boot.c  **** 							
 2424               		.loc 1 1733 0
 2425 0930 2601      		movw r4,r12
 2426 0932 3701      		movw r6,r14
 2427 0934 440C      		lsl r4
 2428 0936 551C      		rol r5
 2429 0938 661C      		rol r6
 2430 093a 771C      		rol r7
1735:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2431               		.loc 1 1735 0
 2432 093c 60E0      		ldi r22,0
 2433 093e 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2434 0940 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2435 0942 0E94 0000 		call PrintFromPROGMEM_p
 2436               	.LVL275:
1736:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2437               		.loc 1 1736 0
 2438 0946 8E2D      		mov r24,r14
 2439 0948 0E94 0000 		call PrintHexByte
 2440               	.LVL276:
1737:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2441               		.loc 1 1737 0
 2442 094c 8D2D      		mov r24,r13
 2443 094e 0E94 0000 		call PrintHexByte
 2444               	.LVL277:
1738:stk500boot.c  **** 			sendchar(0x20);
 2445               		.loc 1 1738 0
 2446 0952 8C2D      		mov r24,r12
 2447 0954 0E94 0000 		call PrintHexByte
 2448               	.LVL278:
1739:stk500boot.c  **** 			sendchar('>');
 2449               		.loc 1 1739 0
 2450 0958 80E2      		ldi r24,lo8(32)
 2451 095a 0E94 0000 		call sendchar
 2452               	.LVL279:
1740:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2453               		.loc 1 1740 0
 2454 095e 8EE3      		ldi r24,lo8(62)
 2455 0960 0E94 0000 		call sendchar
 2456               	.LVL280:
1741:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2457               		.loc 1 1741 0
 2458 0964 862D      		mov r24,r6
 2459               	.LVL281:
 2460               	.L284:
 2461 0966 0E94 0000 		call PrintHexByte
 2462               	.LVL282:
1742:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2463               		.loc 1 1742 0
 2464 096a 852D      		mov r24,r5
 2465 096c 0E94 0000 		call PrintHexByte
 2466               	.LVL283:
1743:stk500boot.c  **** 		}
 2467               		.loc 1 1743 0
 2468 0970 842D      		mov r24,r4
 2469 0972 0E94 0000 		call PrintHexByte
 2470               	.LVL284:
 2471               	.L103:
1755:stk500boot.c  **** 
 2472               		.loc 1 1755 0
 2473 0976 0E94 0000 		call PrintNewLine
 2474               	.LVL285:
1664:stk500boot.c  **** 	{
 2475               		.loc 1 1664 0
 2476 097a 49E3      		ldi r20,57
 2477 097c 2416      		cp r2,r20
 2478 097e 3104      		cpc r3,__zero_reg__
 2479 0980 01F0      		breq .+2
 2480 0982 00C0      		rjmp .L105
 2481 0984 00C0      		rjmp .L202
 2482               	.LVL286:
 2483               	.L84:
 2484               	.LBE216:
 2485               	.LBE215:
2121:stk500boot.c  **** 				VectorDisplay();
2122:stk500boot.c  **** 				break;
2123:stk500boot.c  **** 
2124:stk500boot.c  **** 			case 'Y':
2125:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HELP_MSG_Y, 2);
 2486               		.loc 1 2125 0
 2487 0986 62E0      		ldi r22,lo8(2)
 2488 0988 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2489 098a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2490 098c 0E94 0000 		call PrintFromPROGMEMln_p
 2491               	.LVL287:
 2492               	.LBB221:
 2493               	.LBB191:
1829:stk500boot.c  **** 
 2494               		.loc 1 1829 0
 2495 0990 60E0      		ldi r22,0
 2496 0992 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2497 0994 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2498 0996 0E94 0000 		call PrintFromPROGMEM_p
 2499               	.LVL288:
1831:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2500               		.loc 1 1831 0
 2501 099a 0E94 0000 		call recchar
 2502               	.LVL289:
1832:stk500boot.c  **** 	sendchar(portLetter);
 2503               		.loc 1 1832 0
 2504 099e 082F      		mov r16,r24
 2505               	.LVL290:
 2506 09a0 0F75      		andi r16,lo8(95)
 2507               	.LVL291:
1833:stk500boot.c  **** 	PrintNewLine();
 2508               		.loc 1 1833 0
 2509 09a2 802F      		mov r24,r16
 2510 09a4 0E94 0000 		call sendchar
 2511               	.LVL292:
1834:stk500boot.c  **** 
 2512               		.loc 1 1834 0
 2513 09a8 0E94 0000 		call PrintNewLine
 2514               	.LVL293:
1836:stk500boot.c  **** 	{
 2515               		.loc 1 1836 0
 2516 09ac 8FEB      		ldi r24,lo8(-65)
 2517 09ae 800F      		add r24,r16
 2518 09b0 8A31      		cpi r24,lo8(26)
 2519 09b2 00F0      		brlo .+2
 2520 09b4 00C0      		rjmp .L107
 2521               	.LVL294:
1839:stk500boot.c  **** 		{
 2522               		.loc 1 1839 0
 2523 09b6 0634      		cpi r16,lo8(70)
 2524 09b8 01F4      		brne .+2
 2525 09ba 00C0      		rjmp .L109
 2526 09bc 00F4      		brsh .L110
 2527 09be 0334      		cpi r16,lo8(67)
 2528 09c0 01F4      		brne .+2
 2529 09c2 00C0      		rjmp .L111
 2530 09c4 00F4      		brsh .L112
 2531 09c6 0134      		cpi r16,lo8(65)
 2532 09c8 01F0      		breq .L113
 2533 09ca 0234      		cpi r16,lo8(66)
 2534 09cc 01F0      		breq .+2
 2535 09ce 00C0      		rjmp .L108
1855:stk500boot.c  **** 				while (!Serial_Available())
 2536               		.loc 1 1855 0
 2537 09d0 14B9      		out 0x4,r17
 2538 09d2 00C0      		rjmp .L126
 2539               	.L112:
1839:stk500boot.c  **** 		{
 2540               		.loc 1 1839 0
 2541 09d4 0434      		cpi r16,lo8(68)
 2542 09d6 01F4      		brne .+2
 2543 09d8 00C0      		rjmp .L115
 2544 09da 0534      		cpi r16,lo8(69)
 2545 09dc 01F0      		breq .+2
 2546 09de 00C0      		rjmp .L108
1891:stk500boot.c  **** 				while (!Serial_Available())
 2547               		.loc 1 1891 0
 2548 09e0 1DB9      		out 0xd,r17
 2549 09e2 00C0      		rjmp .L132
 2550               	.L110:
1839:stk500boot.c  **** 		{
 2551               		.loc 1 1839 0
 2552 09e4 0A34      		cpi r16,lo8(74)
 2553 09e6 01F4      		brne .+2
 2554 09e8 00C0      		rjmp .L117
 2555 09ea 00F4      		brsh .L118
 2556 09ec 0734      		cpi r16,lo8(71)
 2557 09ee 01F4      		brne .+2
 2558 09f0 00C0      		rjmp .L119
 2559 09f2 0834      		cpi r16,lo8(72)
 2560 09f4 01F0      		breq .+2
 2561 09f6 00C0      		rjmp .L108
1927:stk500boot.c  **** 				while (!Serial_Available())
 2562               		.loc 1 1927 0
 2563 09f8 1093 0101 		sts 257,r17
 2564 09fc 00C0      		rjmp .L138
 2565               	.L118:
1839:stk500boot.c  **** 		{
 2566               		.loc 1 1839 0
 2567 09fe 0B34      		cpi r16,lo8(75)
 2568 0a00 01F4      		brne .+2
 2569 0a02 00C0      		rjmp .L121
 2570 0a04 0C34      		cpi r16,lo8(76)
 2571 0a06 01F0      		breq .+2
 2572 0a08 00C0      		rjmp .L108
1975:stk500boot.c  **** 				while (!Serial_Available())
 2573               		.loc 1 1975 0
 2574 0a0a 1093 0A01 		sts 266,r17
 2575 0a0e 00C0      		rjmp .L144
 2576               	.L113:
1843:stk500boot.c  **** 				while (!Serial_Available())
 2577               		.loc 1 1843 0
 2578 0a10 11B9      		out 0x1,r17
 2579               	.L123:
 2580               	.LBB168:
 2581               	.LBB169:
 480:stk500boot.c  **** }
 2582               		.loc 1 480 0
 2583 0a12 8091 C800 		lds r24,200
 2584               	.LBE169:
 2585               	.LBE168:
1844:stk500boot.c  **** 				{
 2586               		.loc 1 1844 0
 2587 0a16 87FD      		sbrc r24,7
 2588 0a18 00C0      		rjmp .L292
1846:stk500boot.c  **** 					delay_ms(200);
 2589               		.loc 1 1846 0
 2590 0a1a 82B1      		in r24,0x2
 2591 0a1c 8095      		com r24
 2592 0a1e 82B9      		out 0x2,r24
1847:stk500boot.c  **** 				}
 2593               		.loc 1 1847 0
 2594 0a20 88EC      		ldi r24,lo8(-56)
 2595 0a22 90E0      		ldi r25,0
 2596 0a24 0E94 0000 		call delay_ms
 2597               	.LVL295:
 2598 0a28 00C0      		rjmp .L123
 2599               	.L126:
 2600               	.LBB170:
 2601               	.LBB171:
 480:stk500boot.c  **** }
 2602               		.loc 1 480 0
 2603 0a2a 8091 C800 		lds r24,200
 2604               	.LBE171:
 2605               	.LBE170:
1856:stk500boot.c  **** 				{
 2606               		.loc 1 1856 0
 2607 0a2e 87FD      		sbrc r24,7
 2608 0a30 00C0      		rjmp .L293
1858:stk500boot.c  **** 					delay_ms(200);
 2609               		.loc 1 1858 0
 2610 0a32 85B1      		in r24,0x5
 2611 0a34 8095      		com r24
 2612 0a36 85B9      		out 0x5,r24
1859:stk500boot.c  **** 				}
 2613               		.loc 1 1859 0
 2614 0a38 88EC      		ldi r24,lo8(-56)
 2615 0a3a 90E0      		ldi r25,0
 2616 0a3c 0E94 0000 		call delay_ms
 2617               	.LVL296:
 2618 0a40 00C0      		rjmp .L126
 2619               	.L293:
1861:stk500boot.c  **** 				break;
 2620               		.loc 1 1861 0
 2621 0a42 15B8      		out 0x5,__zero_reg__
 2622 0a44 00C0      		rjmp .L125
 2623               	.L111:
1867:stk500boot.c  **** 				while (!Serial_Available())
 2624               		.loc 1 1867 0
 2625 0a46 17B9      		out 0x7,r17
 2626               	.L128:
 2627               	.LBB172:
 2628               	.LBB173:
 480:stk500boot.c  **** }
 2629               		.loc 1 480 0
 2630 0a48 8091 C800 		lds r24,200
 2631               	.LBE173:
 2632               	.LBE172:
1868:stk500boot.c  **** 				{
 2633               		.loc 1 1868 0
 2634 0a4c 87FD      		sbrc r24,7
 2635 0a4e 00C0      		rjmp .L294
1870:stk500boot.c  **** 					delay_ms(200);
 2636               		.loc 1 1870 0
 2637 0a50 88B1      		in r24,0x8
 2638 0a52 8095      		com r24
 2639 0a54 88B9      		out 0x8,r24
1871:stk500boot.c  **** 				}
 2640               		.loc 1 1871 0
 2641 0a56 88EC      		ldi r24,lo8(-56)
 2642 0a58 90E0      		ldi r25,0
 2643 0a5a 0E94 0000 		call delay_ms
 2644               	.LVL297:
 2645 0a5e 00C0      		rjmp .L128
 2646               	.L294:
1873:stk500boot.c  **** 				break;
 2647               		.loc 1 1873 0
 2648 0a60 18B8      		out 0x8,__zero_reg__
 2649 0a62 00C0      		rjmp .L125
 2650               	.L115:
1879:stk500boot.c  **** 				while (!Serial_Available())
 2651               		.loc 1 1879 0
 2652 0a64 1AB9      		out 0xa,r17
 2653               	.L130:
 2654               	.LBB174:
 2655               	.LBB175:
 480:stk500boot.c  **** }
 2656               		.loc 1 480 0
 2657 0a66 8091 C800 		lds r24,200
 2658               	.LBE175:
 2659               	.LBE174:
1880:stk500boot.c  **** 				{
 2660               		.loc 1 1880 0
 2661 0a6a 87FD      		sbrc r24,7
 2662 0a6c 00C0      		rjmp .L295
1882:stk500boot.c  **** 					delay_ms(200);
 2663               		.loc 1 1882 0
 2664 0a6e 8BB1      		in r24,0xb
 2665 0a70 8095      		com r24
 2666 0a72 8BB9      		out 0xb,r24
1883:stk500boot.c  **** 				}
 2667               		.loc 1 1883 0
 2668 0a74 88EC      		ldi r24,lo8(-56)
 2669 0a76 90E0      		ldi r25,0
 2670 0a78 0E94 0000 		call delay_ms
 2671               	.LVL298:
 2672 0a7c 00C0      		rjmp .L130
 2673               	.L295:
1885:stk500boot.c  **** 				break;
 2674               		.loc 1 1885 0
 2675 0a7e 1BB8      		out 0xb,__zero_reg__
 2676 0a80 00C0      		rjmp .L125
 2677               	.L132:
 2678               	.LBB176:
 2679               	.LBB177:
 480:stk500boot.c  **** }
 2680               		.loc 1 480 0
 2681 0a82 8091 C800 		lds r24,200
 2682               	.LBE177:
 2683               	.LBE176:
1892:stk500boot.c  **** 				{
 2684               		.loc 1 1892 0
 2685 0a86 87FD      		sbrc r24,7
 2686 0a88 00C0      		rjmp .L296
1894:stk500boot.c  **** 					delay_ms(200);
 2687               		.loc 1 1894 0
 2688 0a8a 8EB1      		in r24,0xe
 2689 0a8c 8095      		com r24
 2690 0a8e 8EB9      		out 0xe,r24
1895:stk500boot.c  **** 				}
 2691               		.loc 1 1895 0
 2692 0a90 88EC      		ldi r24,lo8(-56)
 2693 0a92 90E0      		ldi r25,0
 2694 0a94 0E94 0000 		call delay_ms
 2695               	.LVL299:
 2696 0a98 00C0      		rjmp .L132
 2697               	.L296:
1897:stk500boot.c  **** 				break;
 2698               		.loc 1 1897 0
 2699 0a9a 1EB8      		out 0xe,__zero_reg__
 2700 0a9c 00C0      		rjmp .L125
 2701               	.L109:
1903:stk500boot.c  **** 				while (!Serial_Available())
 2702               		.loc 1 1903 0
 2703 0a9e 10BB      		out 0x10,r17
 2704               	.L134:
 2705               	.LBB178:
 2706               	.LBB179:
 480:stk500boot.c  **** }
 2707               		.loc 1 480 0
 2708 0aa0 8091 C800 		lds r24,200
 2709               	.LBE179:
 2710               	.LBE178:
1904:stk500boot.c  **** 				{
 2711               		.loc 1 1904 0
 2712 0aa4 87FD      		sbrc r24,7
 2713 0aa6 00C0      		rjmp .L297
1906:stk500boot.c  **** 					delay_ms(200);
 2714               		.loc 1 1906 0
 2715 0aa8 81B3      		in r24,0x11
 2716 0aaa 8095      		com r24
 2717 0aac 81BB      		out 0x11,r24
1907:stk500boot.c  **** 				}
 2718               		.loc 1 1907 0
 2719 0aae 88EC      		ldi r24,lo8(-56)
 2720 0ab0 90E0      		ldi r25,0
 2721 0ab2 0E94 0000 		call delay_ms
 2722               	.LVL300:
 2723 0ab6 00C0      		rjmp .L134
 2724               	.L297:
1909:stk500boot.c  **** 				break;
 2725               		.loc 1 1909 0
 2726 0ab8 11BA      		out 0x11,__zero_reg__
 2727 0aba 00C0      		rjmp .L125
 2728               	.L119:
1915:stk500boot.c  **** 				while (!Serial_Available())
 2729               		.loc 1 1915 0
 2730 0abc 13BB      		out 0x13,r17
 2731               	.L136:
 2732               	.LBB180:
 2733               	.LBB181:
 480:stk500boot.c  **** }
 2734               		.loc 1 480 0
 2735 0abe 8091 C800 		lds r24,200
 2736               	.LBE181:
 2737               	.LBE180:
1916:stk500boot.c  **** 				{
 2738               		.loc 1 1916 0
 2739 0ac2 87FD      		sbrc r24,7
 2740 0ac4 00C0      		rjmp .L298
1918:stk500boot.c  **** 					delay_ms(200);
 2741               		.loc 1 1918 0
 2742 0ac6 84B3      		in r24,0x14
 2743 0ac8 8095      		com r24
 2744 0aca 84BB      		out 0x14,r24
1919:stk500boot.c  **** 				}
 2745               		.loc 1 1919 0
 2746 0acc 88EC      		ldi r24,lo8(-56)
 2747 0ace 90E0      		ldi r25,0
 2748 0ad0 0E94 0000 		call delay_ms
 2749               	.LVL301:
 2750 0ad4 00C0      		rjmp .L136
 2751               	.L298:
1921:stk500boot.c  **** 				break;
 2752               		.loc 1 1921 0
 2753 0ad6 14BA      		out 0x14,__zero_reg__
 2754 0ad8 00C0      		rjmp .L125
 2755               	.L138:
 2756               	.LBB182:
 2757               	.LBB183:
 480:stk500boot.c  **** }
 2758               		.loc 1 480 0
 2759 0ada 8091 C800 		lds r24,200
 2760               	.LBE183:
 2761               	.LBE182:
1928:stk500boot.c  **** 				{
 2762               		.loc 1 1928 0
 2763 0ade 87FD      		sbrc r24,7
 2764 0ae0 00C0      		rjmp .L299
1930:stk500boot.c  **** 					delay_ms(200);
 2765               		.loc 1 1930 0
 2766 0ae2 8091 0201 		lds r24,258
 2767 0ae6 8095      		com r24
 2768 0ae8 8093 0201 		sts 258,r24
1931:stk500boot.c  **** 				}
 2769               		.loc 1 1931 0
 2770 0aec 88EC      		ldi r24,lo8(-56)
 2771 0aee 90E0      		ldi r25,0
 2772 0af0 0E94 0000 		call delay_ms
 2773               	.LVL302:
 2774 0af4 00C0      		rjmp .L138
 2775               	.L299:
1933:stk500boot.c  **** 				break;
 2776               		.loc 1 1933 0
 2777 0af6 1092 0201 		sts 258,__zero_reg__
 2778 0afa 00C0      		rjmp .L125
 2779               	.L117:
1951:stk500boot.c  **** 				while (!Serial_Available())
 2780               		.loc 1 1951 0
 2781 0afc 1093 0401 		sts 260,r17
 2782               	.L140:
 2783               	.LBB184:
 2784               	.LBB185:
 480:stk500boot.c  **** }
 2785               		.loc 1 480 0
 2786 0b00 8091 C800 		lds r24,200
 2787               	.LBE185:
 2788               	.LBE184:
1952:stk500boot.c  **** 				{
 2789               		.loc 1 1952 0
 2790 0b04 87FD      		sbrc r24,7
 2791 0b06 00C0      		rjmp .L300
1954:stk500boot.c  **** 					delay_ms(200);
 2792               		.loc 1 1954 0
 2793 0b08 8091 0501 		lds r24,261
 2794 0b0c 8095      		com r24
 2795 0b0e 8093 0501 		sts 261,r24
1955:stk500boot.c  **** 				}
 2796               		.loc 1 1955 0
 2797 0b12 88EC      		ldi r24,lo8(-56)
 2798 0b14 90E0      		ldi r25,0
 2799 0b16 0E94 0000 		call delay_ms
 2800               	.LVL303:
 2801 0b1a 00C0      		rjmp .L140
 2802               	.L300:
1957:stk500boot.c  **** 				break;
 2803               		.loc 1 1957 0
 2804 0b1c 1092 0501 		sts 261,__zero_reg__
 2805 0b20 00C0      		rjmp .L125
 2806               	.L121:
1963:stk500boot.c  **** 				while (!Serial_Available())
 2807               		.loc 1 1963 0
 2808 0b22 1093 0701 		sts 263,r17
 2809               	.L142:
 2810               	.LBB186:
 2811               	.LBB187:
 480:stk500boot.c  **** }
 2812               		.loc 1 480 0
 2813 0b26 8091 C800 		lds r24,200
 2814               	.LBE187:
 2815               	.LBE186:
1964:stk500boot.c  **** 				{
 2816               		.loc 1 1964 0
 2817 0b2a 87FD      		sbrc r24,7
 2818 0b2c 00C0      		rjmp .L301
1966:stk500boot.c  **** 					delay_ms(200);
 2819               		.loc 1 1966 0
 2820 0b2e 8091 0801 		lds r24,264
 2821 0b32 8095      		com r24
 2822 0b34 8093 0801 		sts 264,r24
1967:stk500boot.c  **** 				}
 2823               		.loc 1 1967 0
 2824 0b38 88EC      		ldi r24,lo8(-56)
 2825 0b3a 90E0      		ldi r25,0
 2826 0b3c 0E94 0000 		call delay_ms
 2827               	.LVL304:
 2828 0b40 00C0      		rjmp .L142
 2829               	.L301:
1969:stk500boot.c  **** 				break;
 2830               		.loc 1 1969 0
 2831 0b42 1092 0801 		sts 264,__zero_reg__
 2832 0b46 00C0      		rjmp .L125
 2833               	.L144:
 2834               	.LBB188:
 2835               	.LBB189:
 480:stk500boot.c  **** }
 2836               		.loc 1 480 0
 2837 0b48 8091 C800 		lds r24,200
 2838               	.LBE189:
 2839               	.LBE188:
1976:stk500boot.c  **** 				{
 2840               		.loc 1 1976 0
 2841 0b4c 87FD      		sbrc r24,7
 2842 0b4e 00C0      		rjmp .L302
1978:stk500boot.c  **** 					delay_ms(200);
 2843               		.loc 1 1978 0
 2844 0b50 8091 0B01 		lds r24,267
 2845 0b54 8095      		com r24
 2846 0b56 8093 0B01 		sts 267,r24
1979:stk500boot.c  **** 				}
 2847               		.loc 1 1979 0
 2848 0b5a 88EC      		ldi r24,lo8(-56)
 2849 0b5c 90E0      		ldi r25,0
 2850 0b5e 0E94 0000 		call delay_ms
 2851               	.LVL305:
 2852 0b62 00C0      		rjmp .L144
 2853               	.L302:
1981:stk500boot.c  **** 				break;
 2854               		.loc 1 1981 0
 2855 0b64 1092 0B01 		sts 267,__zero_reg__
 2856 0b68 00C0      		rjmp .L125
 2857               	.L108:
1986:stk500boot.c  **** 				getCharFlag	=	false;
 2858               		.loc 1 1986 0
 2859 0b6a 60E0      		ldi r22,0
 2860 0b6c 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2861 0b6e 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2862 0b70 00C0      		rjmp .L282
 2863               	.LVL306:
 2864               	.L107:
1997:stk500boot.c  **** 	}
 2865               		.loc 1 1997 0
 2866 0b72 60E0      		ldi r22,0
 2867 0b74 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 2868 0b76 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 2869 0b78 00C0      		rjmp .L282
 2870               	.LVL307:
 2871               	.L70:
 2872               	.LBE191:
 2873               	.LBE221:
2126:stk500boot.c  **** 				AVR_PortOutput();
2127:stk500boot.c  **** 				break;
2128:stk500boot.c  **** 			
2129:stk500boot.c  **** 			default:
2130:stk500boot.c  **** 				PrintFromPROGMEMln_p(gTextMsg_HUH, 0);
 2874               		.loc 1 2130 0
 2875 0b7a 60E0      		ldi r22,0
 2876 0b7c 80E0      		ldi r24,lo8(gTextMsg_HUH)
 2877 0b7e 90E0      		ldi r25,hi8(gTextMsg_HUH)
 2878               	.LVL308:
 2879               	.L282:
 2880 0b80 0E94 0000 		call PrintFromPROGMEMln_p
 2881               	.LVL309:
 2882 0b84 00C0      		rjmp .L202
 2883               	.LVL310:
 2884               	.L62:
 2885               	.LBE222:
 2886               	.LBE223:
 710:stk500boot.c  **** 				{
 2887               		.loc 1 710 0
 2888 0b86 8330      		cpi r24,lo8(3)
 2889 0b88 01F0      		breq .L209
 2890 0b8a 00F4      		brsh .L148
 2891 0b8c 8130      		cpi r24,lo8(1)
 2892 0b8e 01F0      		breq .L207
 2893 0b90 00F0      		brlo .L278
 2894 0b92 00C0      		rjmp .L303
 2895               	.L148:
 2896 0b94 8530      		cpi r24,lo8(5)
 2897 0b96 01F0      		breq .L210
 2898 0b98 00F0      		brlo .L153
 2899 0b9a 8630      		cpi r24,lo8(6)
 2900 0b9c 01F0      		breq .+2
 2901 0b9e 00C0      		rjmp .L304
 706:stk500boot.c  **** 				}
 2902               		.loc 1 706 0
 2903 0ba0 E12C      		mov r14,__zero_reg__
 2904 0ba2 F12C      		mov r15,__zero_reg__
 2905 0ba4 00C0      		rjmp .L154
 2906               	.L278:
 2907 0ba6 E12C      		mov r14,__zero_reg__
 2908 0ba8 F12C      		mov r15,__zero_reg__
 713:stk500boot.c  **** 						{
 2909               		.loc 1 713 0
 2910 0baa 9B31      		cpi r25,lo8(27)
 2911 0bac 01F4      		brne .+2
 2912 0bae 00C0      		rjmp .L212
 2913               	.LVL311:
 2914               	.L156:
 2915 0bb0 00E0      		ldi r16,0
 2916 0bb2 10E0      		ldi r17,0
 2917 0bb4 00C0      		rjmp .L200
 2918               	.LVL312:
 2919               	.L207:
 706:stk500boot.c  **** 				}
 2920               		.loc 1 706 0
 2921 0bb6 E12C      		mov r14,__zero_reg__
 2922 0bb8 F12C      		mov r15,__zero_reg__
 2923               	.LVL313:
 2924               	.L149:
 724:stk500boot.c  **** 					#else
 2925               		.loc 1 724 0
 2926 0bba 7926      		eor r7,r25
 2927               	.LVL314:
 737:stk500boot.c  **** 
 2928               		.loc 1 737 0
 2929 0bbc CA5D      		subi r28,lo8(-294)
 2930 0bbe DE4F      		sbci r29,hi8(-294)
 2931 0bc0 9883      		st Y,r25
 2932 0bc2 C652      		subi r28,lo8(294)
 2933 0bc4 D140      		sbci r29,hi8(294)
 723:stk500boot.c  **** 						checksum		^=	c;
 2934               		.loc 1 723 0
 2935 0bc6 82E0      		ldi r24,lo8(2)
 737:stk500boot.c  **** 
 2936               		.loc 1 737 0
 2937 0bc8 00C0      		rjmp .L156
 2938               	.LVL315:
 2939               	.L303:
 706:stk500boot.c  **** 				}
 2940               		.loc 1 706 0
 2941 0bca E12C      		mov r14,__zero_reg__
 2942 0bcc F12C      		mov r15,__zero_reg__
 2943               	.LVL316:
 2944               	.L150:
 740:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 2945               		.loc 1 740 0
 2946 0bce 292F      		mov r18,r25
 2947               	.LVL317:
 2948 0bd0 30E0      		ldi r19,0
 2949 0bd2 322F      		mov r19,r18
 2950 0bd4 2227      		clr r18
 2951               	.LVL318:
 742:stk500boot.c  **** 						break;
 2952               		.loc 1 742 0
 2953 0bd6 7926      		eor r7,r25
 2954               	.LVL319:
 741:stk500boot.c  **** 						checksum		^=	c;
 2955               		.loc 1 741 0
 2956 0bd8 83E0      		ldi r24,lo8(3)
 743:stk500boot.c  **** 
 2957               		.loc 1 743 0
 2958 0bda 00C0      		rjmp .L156
 2959               	.LVL320:
 2960               	.L209:
 706:stk500boot.c  **** 				}
 2961               		.loc 1 706 0
 2962 0bdc E12C      		mov r14,__zero_reg__
 2963 0bde F12C      		mov r15,__zero_reg__
 2964               	.LVL321:
 2965               	.L147:
 746:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 2966               		.loc 1 746 0
 2967 0be0 292B      		or r18,r25
 2968               	.LVL322:
 748:stk500boot.c  **** 						break;
 2969               		.loc 1 748 0
 2970 0be2 7926      		eor r7,r25
 2971               	.LVL323:
 747:stk500boot.c  **** 						checksum		^=	c;
 2972               		.loc 1 747 0
 2973 0be4 84E0      		ldi r24,lo8(4)
 749:stk500boot.c  **** 
 2974               		.loc 1 749 0
 2975 0be6 00C0      		rjmp .L156
 2976               	.LVL324:
 2977               	.L153:
 752:stk500boot.c  **** 						{
 2978               		.loc 1 752 0
 2979 0be8 9E30      		cpi r25,lo8(14)
 2980 0bea 01F0      		breq .+2
 2981 0bec 00C0      		rjmp .L213
 2982               	.LVL325:
 755:stk500boot.c  **** 							ii				=	0;
 2983               		.loc 1 755 0
 2984 0bee 7926      		eor r7,r25
 2985               	.LVL326:
 706:stk500boot.c  **** 				}
 2986               		.loc 1 706 0
 2987 0bf0 E12C      		mov r14,__zero_reg__
 2988 0bf2 F12C      		mov r15,__zero_reg__
 756:stk500boot.c  **** 						}
 2989               		.loc 1 756 0
 2990 0bf4 C95D      		subi r28,lo8(-295)
 2991 0bf6 DE4F      		sbci r29,hi8(-295)
 2992 0bf8 1982      		std Y+1,__zero_reg__
 2993 0bfa 1882      		st Y,__zero_reg__
 2994 0bfc C752      		subi r28,lo8(295)
 2995 0bfe D140      		sbci r29,hi8(295)
 2996 0c00 00C0      		rjmp .L280
 2997               	.LVL327:
 2998               	.L210:
 706:stk500boot.c  **** 				}
 2999               		.loc 1 706 0
 3000 0c02 E12C      		mov r14,__zero_reg__
 3001 0c04 F12C      		mov r15,__zero_reg__
 3002               	.LVL328:
 3003               	.L152:
 765:stk500boot.c  **** 						checksum		^=	c;
 3004               		.loc 1 765 0
 3005 0c06 C95D      		subi r28,lo8(-295)
 3006 0c08 DE4F      		sbci r29,hi8(-295)
 3007 0c0a 4881      		ld r20,Y
 3008 0c0c 5981      		ldd r21,Y+1
 3009 0c0e C752      		subi r28,lo8(295)
 3010 0c10 D140      		sbci r29,hi8(295)
 3011 0c12 4F5F      		subi r20,-1
 3012 0c14 5F4F      		sbci r21,-1
 3013               	.LVL329:
 3014 0c16 E1E0      		ldi r30,lo8(1)
 3015 0c18 F0E0      		ldi r31,0
 3016 0c1a EC0F      		add r30,r28
 3017 0c1c FD1F      		adc r31,r29
 3018 0c1e C95D      		subi r28,lo8(-295)
 3019 0c20 DE4F      		sbci r29,hi8(-295)
 3020 0c22 6881      		ld r22,Y
 3021 0c24 7981      		ldd r23,Y+1
 3022 0c26 C752      		subi r28,lo8(295)
 3023 0c28 D140      		sbci r29,hi8(295)
 3024 0c2a E60F      		add r30,r22
 3025 0c2c F71F      		adc r31,r23
 3026 0c2e 9083      		st Z,r25
 766:stk500boot.c  **** 						if (ii == msgLength )
 3027               		.loc 1 766 0
 3028 0c30 7926      		eor r7,r25
 3029               	.LVL330:
 767:stk500boot.c  **** 						{
 3030               		.loc 1 767 0
 3031 0c32 2417      		cp r18,r20
 3032 0c34 3507      		cpc r19,r21
 3033 0c36 01F4      		brne .+2
 3034 0c38 00C0      		rjmp .L214
 3035 0c3a C95D      		subi r28,lo8(-295)
 3036 0c3c DE4F      		sbci r29,hi8(-295)
 3037 0c3e 5983      		std Y+1,r21
 3038 0c40 4883      		st Y,r20
 3039 0c42 C752      		subi r28,lo8(295)
 3040 0c44 D140      		sbci r29,hi8(295)
 3041               	.LVL331:
 3042               	.L280:
 3043 0c46 85E0      		ldi r24,lo8(5)
 3044 0c48 00C0      		rjmp .L156
 3045               	.LVL332:
 3046               	.L205:
 706:stk500boot.c  **** 				}
 3047               		.loc 1 706 0
 3048 0c4a E12C      		mov r14,__zero_reg__
 3049 0c4c F12C      		mov r15,__zero_reg__
 3050               	.LVL333:
 3051               	.L63:
 710:stk500boot.c  **** 				{
 3052               		.loc 1 710 0
 3053 0c4e 8330      		cpi r24,lo8(3)
 3054 0c50 01F0      		breq .L147
 3055 0c52 00F4      		brsh .+2
 3056 0c54 00C0      		rjmp .L305
 3057 0c56 8530      		cpi r24,lo8(5)
 3058 0c58 01F0      		breq .L152
 3059 0c5a 00F4      		brsh .+2
 3060 0c5c 00C0      		rjmp .L224
 3061 0c5e 8630      		cpi r24,lo8(6)
 3062 0c60 01F4      		brne .L146
 3063               	.LVL334:
 3064               	.L154:
 774:stk500boot.c  **** 						{
 3065               		.loc 1 774 0
 3066 0c62 9711      		cpse r25,r7
 3067 0c64 00C0      		rjmp .L224
 3068 0c66 00C0      		rjmp .L215
 3069               	.LVL335:
 3070               	.L304:
 706:stk500boot.c  **** 				}
 3071               		.loc 1 706 0
 3072 0c68 E12C      		mov r14,__zero_reg__
 3073 0c6a F12C      		mov r15,__zero_reg__
 3074               	.LVL336:
 3075               	.L146:
 675:stk500boot.c  **** 			{
 3076               		.loc 1 675 0
 3077 0c6c 8730      		cpi r24,lo8(7)
 3078 0c6e 01F0      		breq .+2
 3079 0c70 00C0      		rjmp .L156
 3080               	.LVL337:
 3081               	.L215:
 3082 0c72 612C      		mov r6,__zero_reg__
 3083               	.LVL338:
 3084               	.L101:
 790:stk500boot.c  **** 			{
 3085               		.loc 1 790 0
 3086 0c74 2981      		ldd r18,Y+1
 3087 0c76 2331      		cpi r18,lo8(19)
 3088 0c78 01F4      		brne .+2
 3089 0c7a 00C0      		rjmp .L158
 3090 0c7c 00F4      		brsh .L159
 3091 0c7e 2630      		cpi r18,lo8(6)
 3092 0c80 01F4      		brne .+2
 3093 0c82 00C0      		rjmp .L160
 3094 0c84 00F4      		brsh .L161
 3095 0c86 2230      		cpi r18,lo8(2)
 3096 0c88 01F4      		brne .+2
 3097 0c8a 00C0      		rjmp .L291
 3098 0c8c 2330      		cpi r18,lo8(3)
 3099 0c8e 01F4      		brne .+2
 3100 0c90 00C0      		rjmp .L163
 3101 0c92 2130      		cpi r18,lo8(1)
 3102 0c94 01F0      		breq .+2
 3103 0c96 00C0      		rjmp .L157
 3104               	.LVL339:
 854:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 3105               		.loc 1 854 0
 3106 0c98 1A82      		std Y+2,__zero_reg__
 855:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 3107               		.loc 1 855 0
 3108 0c9a 88E0      		ldi r24,lo8(8)
 3109 0c9c 8B83      		std Y+3,r24
 856:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 3110               		.loc 1 856 0
 3111 0c9e 81E4      		ldi r24,lo8(65)
 3112 0ca0 8C83      		std Y+4,r24
 857:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 3113               		.loc 1 857 0
 3114 0ca2 86E5      		ldi r24,lo8(86)
 3115 0ca4 8D83      		std Y+5,r24
 858:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 3116               		.loc 1 858 0
 3117 0ca6 82E5      		ldi r24,lo8(82)
 3118 0ca8 8E83      		std Y+6,r24
 859:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 3119               		.loc 1 859 0
 3120 0caa 89E4      		ldi r24,lo8(73)
 3121 0cac 8F83      		std Y+7,r24
 860:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 3122               		.loc 1 860 0
 3123 0cae 83E5      		ldi r24,lo8(83)
 3124 0cb0 8887      		std Y+8,r24
 861:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 3125               		.loc 1 861 0
 3126 0cb2 80E5      		ldi r24,lo8(80)
 3127 0cb4 8987      		std Y+9,r24
 862:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 3128               		.loc 1 862 0
 3129 0cb6 8FE5      		ldi r24,lo8(95)
 3130 0cb8 8A87      		std Y+10,r24
 863:stk500boot.c  **** 					break;
 3131               		.loc 1 863 0
 3132 0cba 82E3      		ldi r24,lo8(50)
 3133 0cbc 8B87      		std Y+11,r24
 853:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 3134               		.loc 1 853 0
 3135 0cbe 0BE0      		ldi r16,lo8(11)
 3136 0cc0 10E0      		ldi r17,0
 864:stk500boot.c  **** 
 3137               		.loc 1 864 0
 3138 0cc2 00C0      		rjmp .L177
 3139               	.LVL340:
 3140               	.L161:
 790:stk500boot.c  **** 			{
 3141               		.loc 1 790 0
 3142 0cc4 2131      		cpi r18,lo8(17)
 3143 0cc6 01F4      		brne .+2
 3144 0cc8 00C0      		rjmp .L216
 3145 0cca 00F0      		brlo .+2
 3146 0ccc 00C0      		rjmp .L166
 3147 0cce 2031      		cpi r18,lo8(16)
 3148 0cd0 01F4      		brne .+2
 3149 0cd2 00C0      		rjmp .L291
 3150 0cd4 00C0      		rjmp .L157
 3151               	.L159:
 3152 0cd6 2831      		cpi r18,lo8(24)
 3153 0cd8 01F4      		brne .+2
 3154 0cda 00C0      		rjmp .L167
 3155 0cdc 00F4      		brsh .L168
 3156 0cde 2531      		cpi r18,lo8(21)
 3157 0ce0 01F4      		brne .+2
 3158 0ce2 00C0      		rjmp .L158
 3159 0ce4 00F4      		brsh .+2
 3160 0ce6 00C0      		rjmp .L169
 3161 0ce8 2631      		cpi r18,lo8(22)
 3162 0cea 01F4      		brne .+2
 3163 0cec 00C0      		rjmp .L169
 3164 0cee 00C0      		rjmp .L157
 3165               	.L168:
 3166 0cf0 2A31      		cpi r18,lo8(26)
 3167 0cf2 01F4      		brne .+2
 3168 0cf4 00C0      		rjmp .L170
 3169 0cf6 00F4      		brsh .+2
 3170 0cf8 00C0      		rjmp .L171
 3171 0cfa 2B31      		cpi r18,lo8(27)
 3172 0cfc 01F4      		brne .+2
 3173 0cfe 00C0      		rjmp .L172
 3174 0d00 2D31      		cpi r18,lo8(29)
 3175 0d02 01F0      		breq .+2
 3176 0d04 00C0      		rjmp .L157
 3177               	.LVL341:
 3178               	.LBB224:
 798:stk500boot.c  **** 						{
 3179               		.loc 1 798 0
 3180 0d06 9D81      		ldd r25,Y+5
 3181 0d08 9033      		cpi r25,lo8(48)
 3182 0d0a 01F4      		brne .L174
 3183               	.LBB225:
 800:stk500boot.c  **** 
 3184               		.loc 1 800 0
 3185 0d0c 8F81      		ldd r24,Y+7
 3186               	.LVL342:
 802:stk500boot.c  **** 							{
 3187               		.loc 1 802 0
 3188 0d0e 8823      		tst r24
 3189 0d10 01F0      		breq .L217
 806:stk500boot.c  **** 							{
 3190               		.loc 1 806 0
 3191 0d12 8130      		cpi r24,lo8(1)
 3192 0d14 01F4      		brne .L218
 808:stk500boot.c  **** 							}
 3193               		.loc 1 808 0
 3194 0d16 88E9      		ldi r24,lo8(-104)
 3195               	.LVL343:
 3196 0d18 00C0      		rjmp .L175
 3197               	.LVL344:
 3198               	.L174:
 3199               	.LBE225:
 815:stk500boot.c  **** 						{
 3200               		.loc 1 815 0
 3201 0d1a 892F      		mov r24,r25
 3202 0d1c 8075      		andi r24,lo8(80)
 3203 0d1e 01F0      		breq .L220
 822:stk500boot.c  **** 							{
 3204               		.loc 1 822 0
 3205 0d20 9035      		cpi r25,lo8(80)
 3206 0d22 01F4      		brne .L176
 3207               	.LBB226:
 824:stk500boot.c  **** 							}
 3208               		.loc 1 824 0
 3209 0d24 89E0      		ldi r24,lo8(9)
 3210 0d26 E0E0      		ldi r30,0
 3211 0d28 F0E0      		ldi r31,0
 3212 0d2a 00C0      		rjmp .L285
 3213               	.L176:
 3214               	.LBE226:
 826:stk500boot.c  **** 							{
 3215               		.loc 1 826 0
 3216 0d2c 9835      		cpi r25,lo8(88)
 3217 0d2e 01F4      		brne .L220
 3218               	.LBB227:
 828:stk500boot.c  **** 							}
 3219               		.loc 1 828 0
 3220 0d30 89E0      		ldi r24,lo8(9)
 3221 0d32 E3E0      		ldi r30,lo8(3)
 3222 0d34 F0E0      		ldi r31,0
 3223               	.L285:
 3224               	/* #APP */
 3225               	 ;  828 "stk500boot.c" 1
 3226 0d36 8093 5700 		sts 87, r24
 3227 0d3a 8491      		lpm r24, Z
 3228               		
 3229               	 ;  0 "" 2
 3230               	.LVL345:
 3231               	/* #NOAPP */
 3232               	.LBE227:
 3233 0d3c 00C0      		rjmp .L175
 3234               	.LVL346:
 3235               	.L217:
 3236               	.LBB228:
 804:stk500boot.c  **** 							}
 3237               		.loc 1 804 0
 3238 0d3e 8EE1      		ldi r24,lo8(30)
 3239               	.LVL347:
 3240 0d40 00C0      		rjmp .L175
 3241               	.LVL348:
 3242               	.L218:
 812:stk500boot.c  **** 							}
 3243               		.loc 1 812 0
 3244 0d42 81E0      		ldi r24,lo8(1)
 3245               	.LVL349:
 3246 0d44 00C0      		rjmp .L175
 3247               	.LVL350:
 3248               	.L220:
 3249               	.LBE228:
 837:stk500boot.c  **** 						}
 3250               		.loc 1 837 0
 3251 0d46 80E0      		ldi r24,0
 3252               	.L175:
 3253               	.LVL351:
 842:stk500boot.c  **** 							msgBuffer[2]	=	0;
 3254               		.loc 1 842 0
 3255 0d48 1A82      		std Y+2,__zero_reg__
 843:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 3256               		.loc 1 843 0
 3257 0d4a 1B82      		std Y+3,__zero_reg__
 844:stk500boot.c  **** 							msgBuffer[4]	=	0;
 3258               		.loc 1 844 0
 3259 0d4c 9C83      		std Y+4,r25
 845:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 3260               		.loc 1 845 0
 3261 0d4e 1D82      		std Y+5,__zero_reg__
 846:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 3262               		.loc 1 846 0
 3263 0d50 8E83      		std Y+6,r24
 847:stk500boot.c  **** 						}
 3264               		.loc 1 847 0
 3265 0d52 1F82      		std Y+7,__zero_reg__
 841:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 3266               		.loc 1 841 0
 3267 0d54 07E0      		ldi r16,lo8(7)
 3268 0d56 10E0      		ldi r17,0
 3269 0d58 00C0      		rjmp .L177
 3270               	.LVL352:
 3271               	.L163:
 3272 0d5a EA81      		ldd r30,Y+2
 3273 0d5c E059      		subi r30,lo8(-(112))
 3274 0d5e E330      		cpi r30,lo8(3)
 3275 0d60 00F4      		brsh .L221
 3276 0d62 F0E0      		ldi r31,0
 3277 0d64 E050      		subi r30,lo8(-(CSWTCH.68))
 3278 0d66 F040      		sbci r31,hi8(-(CSWTCH.68))
 3279 0d68 8081      		ld r24,Z
 3280 0d6a 00C0      		rjmp .L178
 3281               	.L221:
 3282               	.LBE224:
 3283               	.LBB229:
 870:stk500boot.c  **** 						{
 3284               		.loc 1 870 0
 3285 0d6c 80E0      		ldi r24,0
 3286               	.L178:
 3287               	.LVL353:
 892:stk500boot.c  **** 						msgBuffer[2]	=	value;
 3288               		.loc 1 892 0
 3289 0d6e 1A82      		std Y+2,__zero_reg__
 893:stk500boot.c  **** 					}
 3290               		.loc 1 893 0
 3291 0d70 8B83      		std Y+3,r24
 3292 0d72 00C0      		rjmp .L287
 3293               	.LVL354:
 3294               	.L216:
 3295               	.LBE229:
 898:stk500boot.c  **** 					//*	fall thru
 3296               		.loc 1 898 0
 3297 0d74 6624      		clr r6
 3298 0d76 6394      		inc r6
 3299               	.LVL355:
 3300 0d78 00C0      		rjmp .L291
 3301               	.LVL356:
 3302               	.L172:
 3303               	.LBB230:
 909:stk500boot.c  **** 						unsigned char signature;
 3304               		.loc 1 909 0
 3305 0d7a 8D81      		ldd r24,Y+5
 3306               	.LVL357:
 912:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 3307               		.loc 1 912 0
 3308 0d7c 8823      		tst r24
 3309 0d7e 01F0      		breq .L222
 914:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3310               		.loc 1 914 0
 3311 0d80 8130      		cpi r24,lo8(1)
 3312 0d82 01F4      		brne .L223
 915:stk500boot.c  **** 						else
 3313               		.loc 1 915 0
 3314 0d84 88E9      		ldi r24,lo8(-104)
 3315               	.LVL358:
 3316 0d86 00C0      		rjmp .L290
 3317               	.LVL359:
 3318               	.L222:
 913:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 3319               		.loc 1 913 0
 3320 0d88 8EE1      		ldi r24,lo8(30)
 3321               	.LVL360:
 3322 0d8a 00C0      		rjmp .L290
 3323               	.LVL361:
 3324               	.L223:
 917:stk500boot.c  **** 
 3325               		.loc 1 917 0
 3326 0d8c 81E0      		ldi r24,lo8(1)
 3327               	.LVL362:
 3328 0d8e 00C0      		rjmp .L290
 3329               	.LVL363:
 3330               	.L170:
 3331               	.LBE230:
 928:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3332               		.loc 1 928 0
 3333 0d90 1A82      		std Y+2,__zero_reg__
 3334               	.LBB231:
 929:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3335               		.loc 1 929 0
 3336 0d92 E1E0      		ldi r30,lo8(1)
 3337 0d94 F0E0      		ldi r31,0
 3338 0d96 89E0      		ldi r24,lo8(9)
 3339               	/* #APP */
 3340               	 ;  929 "stk500boot.c" 1
 3341 0d98 8093 5700 		sts 87, r24
 3342 0d9c 8491      		lpm r24, Z
 3343               		
 3344               	 ;  0 "" 2
 3345               	/* #NOAPP */
 3346               	.L289:
 3347               	.LVL364:
 3348               	.LBE231:
 3349 0d9e 8B83      		std Y+3,r24
 930:stk500boot.c  **** 					break;
 3350               		.loc 1 930 0
 3351 0da0 1C82      		std Y+4,__zero_reg__
 927:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3352               		.loc 1 927 0
 3353 0da2 04E0      		ldi r16,lo8(4)
 3354 0da4 10E0      		ldi r17,0
 931:stk500boot.c  **** 
 3355               		.loc 1 931 0
 3356 0da6 00C0      		rjmp .L177
 3357               	.LVL365:
 3358               	.L167:
 3359               	.LBB232:
 937:stk500boot.c  **** 						{
 3360               		.loc 1 937 0
 3361 0da8 8B81      		ldd r24,Y+3
 3362 0daa 8035      		cpi r24,lo8(80)
 3363 0dac 01F4      		brne .L180
 939:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3364               		.loc 1 939 0
 3365 0dae 8C81      		ldd r24,Y+4
 3366 0db0 8830      		cpi r24,lo8(8)
 3367 0db2 01F4      		brne .L181
 3368               	.LBB233:
 940:stk500boot.c  **** 							else
 3369               		.loc 1 940 0
 3370 0db4 E2E0      		ldi r30,lo8(2)
 3371 0db6 F0E0      		ldi r31,0
 3372 0db8 89E0      		ldi r24,lo8(9)
 3373 0dba 00C0      		rjmp .L286
 3374               	.L181:
 3375               	.LBE233:
 3376               	.LBB234:
 942:stk500boot.c  **** 						}
 3377               		.loc 1 942 0
 3378 0dbc 89E0      		ldi r24,lo8(9)
 3379 0dbe E0E0      		ldi r30,0
 3380 0dc0 F0E0      		ldi r31,0
 3381 0dc2 00C0      		rjmp .L286
 3382               	.L180:
 3383               	.LBE234:
 3384               	.LBB235:
 946:stk500boot.c  **** 						}
 3385               		.loc 1 946 0
 3386 0dc4 89E0      		ldi r24,lo8(9)
 3387 0dc6 E3E0      		ldi r30,lo8(3)
 3388 0dc8 F0E0      		ldi r31,0
 3389               	.L286:
 3390               	/* #APP */
 3391               	 ;  946 "stk500boot.c" 1
 3392 0dca 8093 5700 		sts 87, r24
 3393 0dce 8491      		lpm r24, Z
 3394               		
 3395               	 ;  0 "" 2
 3396               	.LVL366:
 3397               	/* #NOAPP */
 3398               	.L290:
 3399               	.LBE235:
 949:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 3400               		.loc 1 949 0
 3401 0dd0 1A82      		std Y+2,__zero_reg__
 3402 0dd2 00C0      		rjmp .L289
 3403               	.LVL367:
 3404               	.L171:
 3405               	.LBE232:
 3406               	.LBB236:
 960:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 3407               		.loc 1 960 0
 3408 0dd4 8D81      		ldd r24,Y+5
 3409               	.LVL368:
 3410               	.LBB237:
 961:stk500boot.c  **** 						boot_spm_busy_wait();
 3411               		.loc 1 961 0
 3412 0dd6 836C      		ori r24,lo8(-61)
 3413               	.LVL369:
 3414 0dd8 99E0      		ldi r25,lo8(9)
 3415               	/* #APP */
 3416               	 ;  961 "stk500boot.c" 1
 3417 0dda E1E0      		ldi r30, 1
 3418 0ddc F0E0      		ldi r31, 0
 3419 0dde 082E      		mov r0, r24
 3420 0de0 9093 5700 		sts 87, r25
 3421 0de4 E895      		spm
 3422               		
 3423               	 ;  0 "" 2
 3424               	/* #NOAPP */
 3425               	.L183:
 3426               	.LBE237:
 962:stk500boot.c  **** 
 3427               		.loc 1 962 0 discriminator 1
 3428 0de6 07B6      		in __tmp_reg__,0x37
 3429 0de8 00FC      		sbrc __tmp_reg__,0
 3430 0dea 00C0      		rjmp .L183
 3431               	.LVL370:
 965:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 3432               		.loc 1 965 0
 3433 0dec 1A82      		std Y+2,__zero_reg__
 966:stk500boot.c  **** 					}
 3434               		.loc 1 966 0
 3435 0dee 1B82      		std Y+3,__zero_reg__
 3436               	.LVL371:
 3437               	.L287:
 964:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3438               		.loc 1 964 0
 3439 0df0 03E0      		ldi r16,lo8(3)
 3440 0df2 10E0      		ldi r17,0
 3441               	.LBE236:
 968:stk500boot.c  **** 	#endif
 3442               		.loc 1 968 0
 3443 0df4 00C0      		rjmp .L177
 3444               	.LVL372:
 3445               	.L166:
 974:stk500boot.c  **** 					break;
 3446               		.loc 1 974 0
 3447 0df6 80EC      		ldi r24,lo8(-64)
 3448 0df8 8A83      		std Y+2,r24
 972:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 3449               		.loc 1 972 0
 3450 0dfa 02E0      		ldi r16,lo8(2)
 3451 0dfc 10E0      		ldi r17,0
 971:stk500boot.c  **** 					msgLength		=	2;
 3452               		.loc 1 971 0
 3453 0dfe CE5D      		subi r28,lo8(-290)
 3454 0e00 DE4F      		sbci r29,hi8(-290)
 3455 0e02 1882      		st Y,__zero_reg__
 3456 0e04 1982      		std Y+1,__zero_reg__
 3457 0e06 1A82      		std Y+2,__zero_reg__
 3458 0e08 1B82      		std Y+3,__zero_reg__
 3459 0e0a C252      		subi r28,lo8(290)
 3460 0e0c D140      		sbci r29,hi8(290)
 975:stk500boot.c  **** 
 3461               		.loc 1 975 0
 3462 0e0e 00C0      		rjmp .L177
 3463               	.LVL373:
 3464               	.L160:
 3465 0e10 6A81      		ldd r22,Y+2
 3466 0e12 7B81      		ldd r23,Y+3
 3467 0e14 8C81      		ldd r24,Y+4
 3468 0e16 9D81      		ldd r25,Y+5
 3469 0e18 0E94 0000 		call __bswapsi2
 979:stk500boot.c  **** 	#else
 3470               		.loc 1 979 0
 3471 0e1c 4B01      		movw r8,r22
 3472 0e1e 5C01      		movw r10,r24
 3473               	.LVL374:
 3474 0e20 880C      		lsl r8
 3475 0e22 991C      		rol r9
 3476 0e24 AA1C      		rol r10
 3477 0e26 BB1C      		rol r11
 3478               	.L291:
 3479               	.LVL375:
 984:stk500boot.c  **** 					break;
 3480               		.loc 1 984 0
 3481 0e28 1A82      		std Y+2,__zero_reg__
 3482 0e2a 00C0      		rjmp .L288
 3483               	.LVL376:
 3484               	.L158:
 3485 0e2c 8A81      		ldd r24,Y+2
 3486 0e2e 9B81      		ldd r25,Y+3
 3487 0e30 9827      		eor r25,r24
 3488 0e32 8927      		eor r24,r25
 3489 0e34 9827      		eor r25,r24
 3490               	.LVL377:
 3491               	.LBB238:
 997:stk500boot.c  **** 						{
 3492               		.loc 1 997 0
 3493 0e36 2331      		cpi r18,lo8(19)
 3494 0e38 01F0      		breq .+2
 3495 0e3a 00C0      		rjmp .L184
1000:stk500boot.c  **** 							{
 3496               		.loc 1 1000 0
 3497 0e3c CE5D      		subi r28,lo8(-290)
 3498 0e3e DE4F      		sbci r29,hi8(-290)
 3499 0e40 2881      		ld r18,Y
 3500 0e42 3981      		ldd r19,Y+1
 3501 0e44 4A81      		ldd r20,Y+2
 3502 0e46 5B81      		ldd r21,Y+3
 3503 0e48 C252      		subi r28,lo8(290)
 3504 0e4a D140      		sbci r29,hi8(290)
 3505 0e4c 2115      		cp r18,__zero_reg__
 3506 0e4e 304E      		sbci r19,-32
 3507 0e50 4340      		sbci r20,3
 3508 0e52 5105      		cpc r21,__zero_reg__
 3509 0e54 00F4      		brsh .L185
1002:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 3510               		.loc 1 1002 0
 3511 0e56 23E0      		ldi r18,lo8(3)
 3512 0e58 CE5D      		subi r28,lo8(-290)
 3513 0e5a DE4F      		sbci r29,hi8(-290)
 3514 0e5c 4881      		ld r20,Y
 3515 0e5e 5981      		ldd r21,Y+1
 3516 0e60 6A81      		ldd r22,Y+2
 3517 0e62 7B81      		ldd r23,Y+3
 3518 0e64 C252      		subi r28,lo8(290)
 3519 0e66 D140      		sbci r29,hi8(290)
 3520               	/* #APP */
 3521               	 ;  1002 "stk500boot.c" 1
 3522 0e68 FA01      		movw r30, r20
 3523 0e6a 6093 5B00 		sts  91, r22
 3524 0e6e 2093 5700 		sts 87, r18
 3525 0e72 E895      		spm
 3526               		
 3527               	 ;  0 "" 2
 3528               	/* #NOAPP */
 3529               	.L186:
1003:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3530               		.loc 1 1003 0 discriminator 1
 3531 0e74 07B6      		in __tmp_reg__,0x37
 3532 0e76 00FC      		sbrc __tmp_reg__,0
 3533 0e78 00C0      		rjmp .L186
1004:stk500boot.c  **** 							}
 3534               		.loc 1 1004 0
 3535 0e7a CE5D      		subi r28,lo8(-290)
 3536 0e7c DE4F      		sbci r29,hi8(-290)
 3537 0e7e 2881      		ld r18,Y
 3538 0e80 3981      		ldd r19,Y+1
 3539 0e82 4A81      		ldd r20,Y+2
 3540 0e84 5B81      		ldd r21,Y+3
 3541 0e86 C252      		subi r28,lo8(290)
 3542 0e88 D140      		sbci r29,hi8(290)
 3543 0e8a 3F5F      		subi r19,-1
 3544 0e8c 4F4F      		sbci r20,-1
 3545 0e8e 5F4F      		sbci r21,-1
 3546 0e90 CE5D      		subi r28,lo8(-290)
 3547 0e92 DE4F      		sbci r29,hi8(-290)
 3548 0e94 2883      		st Y,r18
 3549 0e96 3983      		std Y+1,r19
 3550 0e98 4A83      		std Y+2,r20
 3551 0e9a 5B83      		std Y+3,r21
 3552 0e9c C252      		subi r28,lo8(290)
 3553 0e9e D140      		sbci r29,hi8(290)
 3554               	.LVL378:
 3555               	.L185:
 3556 0ea0 2B85      		ldd r18,Y+11
 3557 0ea2 DE01      		movw r26,r28
 3558 0ea4 1196      		adiw r26,1
 3559               	.LBE238:
 3560               	.LBB239:
 917:stk500boot.c  **** 
 3561               		.loc 1 917 0 discriminator 1
 3562 0ea6 B501      		movw r22,r10
 3563 0ea8 A401      		movw r20,r8
 3564               	.LBE239:
 3565               	.LBB240:
1013:stk500boot.c  **** 
 3566               		.loc 1 1013 0 discriminator 1
 3567 0eaa 11E0      		ldi r17,lo8(1)
 3568               	.LVL379:
 3569               	.L188:
 3570 0eac 1B96      		adiw r26,11
 3571 0eae EC91      		ld r30,X
 3572 0eb0 1B97      		sbiw r26,11
 3573 0eb2 30E0      		ldi r19,0
 3574 0eb4 3E2B      		or r19,r30
 3575               	/* #APP */
 3576               	 ;  1013 "stk500boot.c" 1
 3577 0eb6 0901      		movw  r0, r18
 3578 0eb8 FA01      		movw r30, r20
 3579 0eba 6093 5B00 		sts 91, r22
 3580 0ebe 1093 5700 		sts 87, r17
 3581 0ec2 E895      		spm
 3582 0ec4 1124      		clr  r1
 3583               		
 3584               	 ;  0 "" 2
1015:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3585               		.loc 1 1015 0 discriminator 1
 3586               	/* #NOAPP */
 3587 0ec6 4E5F      		subi r20,-2
 3588 0ec8 5F4F      		sbci r21,-1
 3589 0eca 6F4F      		sbci r22,-1
 3590 0ecc 7F4F      		sbci r23,-1
 3591               	.LVL380:
1016:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 3592               		.loc 1 1016 0 discriminator 1
 3593 0ece 0297      		sbiw r24,2
 3594               	.LVL381:
 3595 0ed0 1296      		adiw r26,2
 3596               	.LVL382:
1017:stk500boot.c  **** 
 3597               		.loc 1 1017 0 discriminator 1
 3598 0ed2 0097      		sbiw r24,0
 3599 0ed4 01F0      		breq .L187
1010:stk500boot.c  **** 
 3600               		.loc 1 1010 0
 3601 0ed6 1A96      		adiw r26,10
 3602 0ed8 2C91      		ld r18,X
 3603 0eda 1A97      		sbiw r26,10
 3604               	.LVL383:
 3605 0edc 00C0      		rjmp .L188
 3606               	.LVL384:
 3607               	.L187:
1019:stk500boot.c  **** 							boot_spm_busy_wait();
 3608               		.loc 1 1019 0
 3609 0ede 35E0      		ldi r19,lo8(5)
 3610               	/* #APP */
 3611               	 ;  1019 "stk500boot.c" 1
 3612 0ee0 F401      		movw r30, r8
 3613 0ee2 A092 5B00 		sts 91, r10
 3614 0ee6 3093 5700 		sts 87, r19
 3615 0eea E895      		spm
 3616               		
 3617               	 ;  0 "" 2
 3618               	/* #NOAPP */
 3619               	.L189:
1020:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 3620               		.loc 1 1020 0 discriminator 1
 3621 0eec 07B6      		in __tmp_reg__,0x37
 3622 0eee 00FC      		sbrc __tmp_reg__,0
 3623 0ef0 00C0      		rjmp .L189
1021:stk500boot.c  **** 						}
 3624               		.loc 1 1021 0
 3625 0ef2 81E1      		ldi r24,lo8(17)
 3626               	.LVL385:
 3627               	/* #APP */
 3628               	 ;  1021 "stk500boot.c" 1
 3629 0ef4 8093 5700 		sts 87, r24
 3630 0ef8 E895      		spm
 3631               		
 3632               	 ;  0 "" 2
 3633               	/* #NOAPP */
 3634 0efa 00C0      		rjmp .L190
 3635               	.LVL386:
 3636               	.L184:
 3637 0efc FE01      		movw r30,r28
 3638 0efe 3196      		adiw r30,1
 3639 0f00 9F01      		movw r18,r30
 3640 0f02 280F      		add r18,r24
 3641 0f04 391F      		adc r19,r25
 997:stk500boot.c  **** 						{
 3642               		.loc 1 997 0
 3643 0f06 B501      		movw r22,r10
 3644 0f08 A401      		movw r20,r8
 3645               	.LVL387:
 3646               	.L192:
1030:stk500boot.c  **** 								EEARH	=	(address >> 8);
 3647               		.loc 1 1030 0
 3648 0f0a 41BD      		out 0x21,r20
1031:stk500boot.c  **** 								address++;						// Select next EEPROM byte
 3649               		.loc 1 1031 0
 3650 0f0c 252E      		mov r2,r21
 3651 0f0e 362E      		mov r3,r22
 3652 0f10 472E      		mov r4,r23
 3653 0f12 5524      		clr r5
 3654 0f14 22BC      		out 0x22,r2
1032:stk500boot.c  **** 
 3655               		.loc 1 1032 0
 3656 0f16 4F5F      		subi r20,-1
 3657 0f18 5F4F      		sbci r21,-1
 3658 0f1a 6F4F      		sbci r22,-1
 3659 0f1c 7F4F      		sbci r23,-1
 3660               	.LVL388:
1034:stk500boot.c  **** 								EECR	|=	(1<<EEMWE);			// Write data into EEPROM
 3661               		.loc 1 1034 0
 3662 0f1e A285      		ldd r26,Z+10
 3663 0f20 A0BD      		out 0x20,r26
1035:stk500boot.c  **** 								EECR	|=	(1<<EEWE);
 3664               		.loc 1 1035 0
 3665 0f22 FA9A      		sbi 0x1f,2
1036:stk500boot.c  **** 
 3666               		.loc 1 1036 0
 3667 0f24 F99A      		sbi 0x1f,1
 3668               	.L191:
1038:stk500boot.c  **** 								size--;						// Decrease number of bytes to write
 3669               		.loc 1 1038 0 discriminator 1
 3670 0f26 F999      		sbic 0x1f,1
 3671 0f28 00C0      		rjmp .L191
 3672 0f2a 3196      		adiw r30,1
 3673               	.LVL389:
1040:stk500boot.c  **** 						#endif
 3674               		.loc 1 1040 0
 3675 0f2c 2E17      		cp r18,r30
 3676 0f2e 3F07      		cpc r19,r31
 3677 0f30 01F4      		brne .L192
 3678 0f32 AC01      		movw r20,r24
 3679               	.LVL390:
 3680 0f34 4150      		subi r20,1
 3681 0f36 5109      		sbc r21,__zero_reg__
 3682 0f38 60E0      		ldi r22,0
 3683 0f3a 70E0      		ldi r23,0
 3684 0f3c 4F5F      		subi r20,-1
 3685 0f3e 5F4F      		sbci r21,-1
 3686 0f40 6F4F      		sbci r22,-1
 3687 0f42 7F4F      		sbci r23,-1
 3688 0f44 480D      		add r20,r8
 3689 0f46 591D      		adc r21,r9
 3690 0f48 6A1D      		adc r22,r10
 3691 0f4a 7B1D      		adc r23,r11
 3692               	.LVL391:
 3693               	.L190:
1044:stk500boot.c  **** 					}
 3694               		.loc 1 1044 0
 3695 0f4c 1A82      		std Y+2,__zero_reg__
 3696               	.LBE240:
1046:stk500boot.c  **** 
 3697               		.loc 1 1046 0
 3698 0f4e 4A01      		movw r8,r20
 3699 0f50 5B01      		movw r10,r22
 3700               	.LVL392:
 3701 0f52 00C0      		rjmp .L288
 3702               	.LVL393:
 3703               	.L169:
 3704 0f54 8A81      		ldd r24,Y+2
 3705 0f56 9B81      		ldd r25,Y+3
 3706 0f58 9827      		eor r25,r24
 3707 0f5a 8927      		eor r24,r25
 3708 0f5c 9827      		eor r25,r24
 3709               	.LVL394:
 3710               	.LBB241:
1053:stk500boot.c  **** 
 3711               		.loc 1 1053 0
 3712 0f5e 8C01      		movw r16,r24
 3713 0f60 0D5F      		subi r16,-3
 3714 0f62 1F4F      		sbci r17,-1
 3715               	.LVL395:
1055:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3716               		.loc 1 1055 0
 3717 0f64 1A82      		std Y+2,__zero_reg__
1056:stk500boot.c  **** 						{
 3718               		.loc 1 1056 0
 3719 0f66 2431      		cpi r18,lo8(20)
 3720 0f68 01F4      		brne .L193
 3721 0f6a DE01      		movw r26,r28
 3722 0f6c 1196      		adiw r26,1
 3723               	.LVL396:
 3724               	.L194:
 3725               	.LBB242:
 3726               	.LBB243:
1064:stk500boot.c  **** 						#else
 3727               		.loc 1 1064 0 discriminator 1
 3728               	/* #APP */
 3729               	 ;  1064 "stk500boot.c" 1
 3730 0f6e ABBE      		out 59, r10
 3731 0f70 F401      		movw r30, r8
 3732 0f72 2791      		elpm r18, Z+
 3733 0f74 3691      		elpm r19, Z
 3734               		
 3735               	 ;  0 "" 2
 3736               	.LVL397:
 3737               	/* #NOAPP */
 3738               	.LBE243:
1068:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3739               		.loc 1 1068 0 discriminator 1
 3740 0f76 1296      		adiw r26,2
 3741 0f78 2C93      		st X,r18
 3742 0f7a 1297      		sbiw r26,2
 3743 0f7c FD01      		movw r30,r26
 3744 0f7e 3496      		adiw r30,4
 3745               	.LVL398:
1069:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3746               		.loc 1 1069 0 discriminator 1
 3747 0f80 1396      		adiw r26,3
 3748 0f82 3C93      		st X,r19
 3749 0f84 1397      		sbiw r26,3
1070:stk500boot.c  **** 								size	-=	2;
 3750               		.loc 1 1070 0 discriminator 1
 3751 0f86 42E0      		ldi r20,2
 3752 0f88 840E      		add r8,r20
 3753 0f8a 911C      		adc r9,__zero_reg__
 3754 0f8c A11C      		adc r10,__zero_reg__
 3755 0f8e B11C      		adc r11,__zero_reg__
 3756               	.LVL399:
1071:stk500boot.c  **** 							}while (size);
 3757               		.loc 1 1071 0 discriminator 1
 3758 0f90 0297      		sbiw r24,2
 3759               	.LVL400:
 3760 0f92 1296      		adiw r26,2
1072:stk500boot.c  **** 						}
 3761               		.loc 1 1072 0 discriminator 1
 3762 0f94 0097      		sbiw r24,0
 3763 0f96 01F4      		brne .L194
 3764 0f98 00C0      		rjmp .L195
 3765               	.LVL401:
 3766               	.L193:
 3767 0f9a FE01      		movw r30,r28
 3768 0f9c 3196      		adiw r30,1
 3769 0f9e 9F01      		movw r18,r30
 3770 0fa0 280F      		add r18,r24
 3771 0fa2 391F      		adc r19,r25
 3772               	.LBE242:
1056:stk500boot.c  **** 						{
 3773               		.loc 1 1056 0 discriminator 1
 3774 0fa4 B501      		movw r22,r10
 3775 0fa6 A401      		movw r20,r8
 3776               	.LVL402:
 3777               	.L196:
1078:stk500boot.c  **** 								EEARH	=	((address >> 8));
 3778               		.loc 1 1078 0 discriminator 1
 3779 0fa8 41BD      		out 0x21,r20
1079:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 3780               		.loc 1 1079 0 discriminator 1
 3781 0faa 252E      		mov r2,r21
 3782 0fac 362E      		mov r3,r22
 3783 0fae 472E      		mov r4,r23
 3784 0fb0 5524      		clr r5
 3785 0fb2 22BC      		out 0x22,r2
1080:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 3786               		.loc 1 1080 0 discriminator 1
 3787 0fb4 4F5F      		subi r20,-1
 3788 0fb6 5F4F      		sbci r21,-1
 3789 0fb8 6F4F      		sbci r22,-1
 3790 0fba 7F4F      		sbci r23,-1
 3791               	.LVL403:
1081:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 3792               		.loc 1 1081 0 discriminator 1
 3793 0fbc F89A      		sbi 0x1f,0
 3794               	.LVL404:
1082:stk500boot.c  **** 								size--;
 3795               		.loc 1 1082 0 discriminator 1
 3796 0fbe A0B5      		in r26,0x20
 3797 0fc0 A283      		std Z+2,r26
 3798 0fc2 3196      		adiw r30,1
 3799               	.LVL405:
1084:stk500boot.c  **** 						}
 3800               		.loc 1 1084 0 discriminator 1
 3801 0fc4 2E17      		cp r18,r30
 3802 0fc6 3F07      		cpc r19,r31
 3803 0fc8 01F4      		brne .L196
 3804 0fca AC01      		movw r20,r24
 3805               	.LVL406:
 3806 0fcc 4150      		subi r20,1
 3807 0fce 5109      		sbc r21,__zero_reg__
 3808 0fd0 60E0      		ldi r22,0
 3809 0fd2 70E0      		ldi r23,0
 3810 0fd4 4F5F      		subi r20,-1
 3811 0fd6 5F4F      		sbci r21,-1
 3812 0fd8 6F4F      		sbci r22,-1
 3813 0fda 7F4F      		sbci r23,-1
 3814 0fdc 840E      		add r8,r20
 3815 0fde 951E      		adc r9,r21
 3816 0fe0 A61E      		adc r10,r22
 3817 0fe2 B71E      		adc r11,r23
 3818 0fe4 E3E0      		ldi r30,lo8(3)
 3819 0fe6 F0E0      		ldi r31,0
 3820               	.LVL407:
 3821 0fe8 EC0F      		add r30,r28
 3822 0fea FD1F      		adc r31,r29
 3823 0fec E80F      		add r30,r24
 3824 0fee F91F      		adc r31,r25
 3825               	.L195:
 3826               	.LVL408:
1086:stk500boot.c  **** 					}
 3827               		.loc 1 1086 0
 3828 0ff0 1082      		st Z,__zero_reg__
 3829               	.LBE241:
1088:stk500boot.c  **** 
 3830               		.loc 1 1088 0
 3831 0ff2 00C0      		rjmp .L177
 3832               	.LVL409:
 3833               	.L157:
1092:stk500boot.c  **** 					break;
 3834               		.loc 1 1092 0
 3835 0ff4 80EC      		ldi r24,lo8(-64)
 3836 0ff6 8A83      		std Y+2,r24
 3837               	.LVL410:
 3838               	.L288:
1091:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3839               		.loc 1 1091 0
 3840 0ff8 02E0      		ldi r16,lo8(2)
 3841 0ffa 10E0      		ldi r17,0
 3842               	.LVL411:
 3843               	.L177:
1099:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
 3844               		.loc 1 1099 0
 3845 0ffc 8BE1      		ldi r24,lo8(27)
 3846 0ffe 0E94 0000 		call sendchar
 3847               	.LVL412:
1102:stk500boot.c  **** 			checksum	^=	seqNum;
 3848               		.loc 1 1102 0
 3849 1002 CA5D      		subi r28,lo8(-294)
 3850 1004 DE4F      		sbci r29,hi8(-294)
 3851 1006 8881      		ld r24,Y
 3852 1008 C652      		subi r28,lo8(294)
 3853 100a D140      		sbci r29,hi8(294)
 3854 100c 0E94 0000 		call sendchar
 3855               	.LVL413:
1106:stk500boot.c  **** 			checksum	^=	c;
 3856               		.loc 1 1106 0
 3857 1010 812F      		mov r24,r17
 3858 1012 0E94 0000 		call sendchar
 3859               	.LVL414:
1110:stk500boot.c  **** 			checksum ^= c;
 3860               		.loc 1 1110 0
 3861 1016 802F      		mov r24,r16
 3862 1018 0E94 0000 		call sendchar
 3863               	.LVL415:
 3864 101c 85E1      		ldi r24,lo8(21)
 3865 101e CA5D      		subi r28,lo8(-294)
 3866 1020 DE4F      		sbci r29,hi8(-294)
 3867 1022 7880      		ld r7,Y
 3868 1024 C652      		subi r28,lo8(294)
 3869 1026 D140      		sbci r29,hi8(294)
 3870 1028 7826      		eor r7,r24
 3871 102a 7026      		eor r7,r16
 3872               	.LVL416:
1113:stk500boot.c  **** 			checksum ^= TOKEN;
 3873               		.loc 1 1113 0
 3874 102c 8EE0      		ldi r24,lo8(14)
 3875 102e 0E94 0000 		call sendchar
 3876               	.LVL417:
1114:stk500boot.c  **** 
 3877               		.loc 1 1114 0
 3878 1032 7126      		eor r7,r17
 3879               	.LVL418:
 3880 1034 BE01      		movw r22,r28
 3881 1036 6F5F      		subi r22,-1
 3882 1038 7F4F      		sbci r23,-1
 3883 103a 6B01      		movw r12,r22
 3884 103c 060F      		add r16,r22
 3885 103e 171F      		adc r17,r23
 3886               	.LVL419:
 3887               	.L197:
1117:stk500boot.c  **** 			{
 3888               		.loc 1 1117 0
 3889 1040 C016      		cp r12,r16
 3890 1042 D106      		cpc r13,r17
 3891 1044 01F0      		breq .L306
 3892               	.LVL420:
1119:stk500boot.c  **** 				sendchar(c);
 3893               		.loc 1 1119 0
 3894 1046 D601      		movw r26,r12
 3895 1048 5D90      		ld r5,X+
 3896               	.LVL421:
 3897 104a 6D01      		movw r12,r26
 3898               	.LVL422:
1120:stk500boot.c  **** 				checksum ^=c;
 3899               		.loc 1 1120 0
 3900 104c 852D      		mov r24,r5
 3901 104e 0E94 0000 		call sendchar
 3902               	.LVL423:
1121:stk500boot.c  **** 				msgLength--;
 3903               		.loc 1 1121 0
 3904 1052 7524      		eor r7,r5
 3905               	.LVL424:
 3906 1054 00C0      		rjmp .L197
 3907               	.LVL425:
 3908               	.L306:
1124:stk500boot.c  **** 			seqNum++;
 3909               		.loc 1 1124 0
 3910 1056 872D      		mov r24,r7
 3911 1058 0E94 0000 		call sendchar
 3912               	.LVL426:
1125:stk500boot.c  **** 	
 3913               		.loc 1 1125 0
 3914 105c CA5D      		subi r28,lo8(-294)
 3915 105e DE4F      		sbci r29,hi8(-294)
 3916 1060 B881      		ld r27,Y
 3917 1062 C652      		subi r28,lo8(294)
 3918 1064 D140      		sbci r29,hi8(294)
 3919 1066 BF5F      		subi r27,lo8(-(1))
 3920 1068 CA5D      		subi r28,lo8(-294)
 3921 106a DE4F      		sbci r29,hi8(-294)
 3922 106c B883      		st Y,r27
 3923 106e C652      		subi r28,lo8(294)
 3924 1070 D140      		sbci r29,hi8(294)
 3925               	.LVL427:
1129:stk500boot.c  **** 		#endif
 3926               		.loc 1 1129 0
 3927 1072 85B1      		in r24,0x5
 3928 1074 8058      		subi r24,lo8(-(-128))
 3929 1076 85B9      		out 0x5,r24
 3930               	.LVL428:
 3931 1078 00E0      		ldi r16,0
 3932 107a 10E0      		ldi r17,0
 669:stk500boot.c  **** 		{
 3933               		.loc 1 669 0
 3934 107c 6620      		tst r6
 3935 107e 01F4      		brne .+4
 3936 1080 0C94 0000 		jmp .L199
 3937               	.LVL429:
 3938               	.L56:
1164:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3939               		.loc 1 1164 0
 3940 1084 2798      		cbi 0x4,7
1165:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 3941               		.loc 1 1165 0
 3942 1086 2F98      		cbi 0x5,7
1167:stk500boot.c  **** #endif
 3943               		.loc 1 1167 0
 3944 1088 84E6      		ldi r24,lo8(100)
 3945 108a 90E0      		ldi r25,0
 3946 108c 0E94 0000 		call delay_ms
 3947               	.LVL430:
1171:stk500boot.c  **** 
 3948               		.loc 1 1171 0
 3949               	/* #APP */
 3950               	 ;  1171 "stk500boot.c" 1
 3951 1090 0000      		nop
 3952               	 ;  0 "" 2
1177:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 3953               		.loc 1 1177 0
 3954               	/* #NOAPP */
 3955 1092 8091 C800 		lds r24,200
 3956 1096 8D7F      		andi r24,lo8(-3)
 3957 1098 8093 C800 		sts 200,r24
1178:stk500boot.c  **** 
 3958               		.loc 1 1178 0
 3959 109c 81E1      		ldi r24,lo8(17)
 3960               	/* #APP */
 3961               	 ;  1178 "stk500boot.c" 1
 3962 109e 8093 5700 		sts 87, r24
 3963 10a2 E895      		spm
 3964               		
 3965               	 ;  0 "" 2
1181:stk500boot.c  **** 			"clr	r30		\n\t"
 3966               		.loc 1 1181 0
 3967               	 ;  1181 "stk500boot.c" 1
 3968 10a4 EE27      		clr	r30		
 3969 10a6 FF27      		clr	r31		
 3970 10a8 0994      		ijmp	
 3971               		
 3972               	 ;  0 "" 2
 3973               	/* #NOAPP */
 3974               	.L201:
 3975 10aa 00C0      		rjmp .L201
 3976               	.LVL431:
 3977               	.L212:
 716:stk500boot.c  **** 						}
 3978               		.loc 1 716 0
 3979 10ac 8BE1      		ldi r24,lo8(27)
 3980 10ae 782E      		mov r7,r24
 3981               	.LVL432:
 715:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 3982               		.loc 1 715 0
 3983 10b0 81E0      		ldi r24,lo8(1)
 3984 10b2 00C0      		rjmp .L156
 3985               	.LVL433:
 3986               	.L213:
 706:stk500boot.c  **** 				}
 3987               		.loc 1 706 0
 3988 10b4 E12C      		mov r14,__zero_reg__
 3989 10b6 F12C      		mov r15,__zero_reg__
 3990 10b8 00C0      		rjmp .L224
 3991               	.LVL434:
 3992               	.L214:
 3993 10ba C95D      		subi r28,lo8(-295)
 3994 10bc DE4F      		sbci r29,hi8(-295)
 3995 10be 3983      		std Y+1,r19
 3996 10c0 2883      		st Y,r18
 3997 10c2 C752      		subi r28,lo8(295)
 3998 10c4 D140      		sbci r29,hi8(295)
 769:stk500boot.c  **** 						}
 3999               		.loc 1 769 0
 4000 10c6 86E0      		ldi r24,lo8(6)
 4001               	.LVL435:
 4002 10c8 00C0      		rjmp .L156
 4003               	.LVL436:
 4004               	.L305:
 710:stk500boot.c  **** 				{
 4005               		.loc 1 710 0
 4006 10ca 8130      		cpi r24,lo8(1)
 4007 10cc 01F4      		brne .+2
 4008 10ce 00C0      		rjmp .L149
 4009 10d0 00F0      		brlo .+2
 4010 10d2 00C0      		rjmp .L150
 4011               	.LVL437:
 4012               	.L224:
 4013 10d4 80E0      		ldi r24,0
 4014               	.LVL438:
 4015 10d6 00C0      		rjmp .L156
 4016               		.cfi_endproc
 4017               	.LFE17:
 4019               		.section	.rodata
 4022               	CSWTCH.68:
 4023 0000 0F        		.byte	15
 4024 0001 02        		.byte	2
 4025 0002 0A        		.byte	10
 4026               	.global	gTextMsg_END
 4027               		.section	.progmem.data,"a",@progbits
 4030               	gTextMsg_END:
 4031 0000 2A00      		.string	"*"
 4032               	.global	gTextMsg_HELP_MSG_Y
 4035               	gTextMsg_HELP_MSG_Y:
 4036 0002 593D 506F 		.string	"Y=Port blink"
 4036      7274 2062 
 4036      6C69 6E6B 
 4036      00
 4037               	.global	gTextMsg_HELP_MSG_V
 4040               	gTextMsg_HELP_MSG_V:
 4041 000f 563D 7368 		.string	"V=show interrupt Vectors"
 4041      6F77 2069 
 4041      6E74 6572 
 4041      7275 7074 
 4041      2056 6563 
 4042               	.global	gTextMsg_HELP_MSG_R
 4045               	gTextMsg_HELP_MSG_R:
 4046 0028 523D 4475 		.string	"R=Dump RAM"
 4046      6D70 2052 
 4046      414D 00
 4047               	.global	gTextMsg_HELP_MSG_Q
 4050               	gTextMsg_HELP_MSG_Q:
 4051 0033 513D 5175 		.string	"Q=Quit"
 4051      6974 00
 4052               	.global	gTextMsg_HELP_MSG_L
 4055               	gTextMsg_HELP_MSG_L:
 4056 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 4056      7374 2049 
 4056      2F4F 2050 
 4056      6F72 7473 
 4056      00
 4057               	.global	gTextMsg_HELP_MSG_H
 4060               	gTextMsg_HELP_MSG_H:
 4061 004b 483D 4865 		.string	"H=Help"
 4061      6C70 00
 4062               	.global	gTextMsg_HELP_MSG_F
 4065               	gTextMsg_HELP_MSG_F:
 4066 0052 463D 4475 		.string	"F=Dump FLASH"
 4066      6D70 2046 
 4066      4C41 5348 
 4066      00
 4067               	.global	gTextMsg_HELP_MSG_E
 4070               	gTextMsg_HELP_MSG_E:
 4071 005f 453D 4475 		.string	"E=Dump EEPROM"
 4071      6D70 2045 
 4071      4550 524F 
 4071      4D00 
 4072               	.global	gTextMsg_HELP_MSG_B
 4075               	gTextMsg_HELP_MSG_B:
 4076 006d 423D 426C 		.string	"B=Blink LED"
 4076      696E 6B20 
 4076      4C45 4400 
 4077               	.global	gTextMsg_HELP_MSG_AT
 4080               	gTextMsg_HELP_MSG_AT:
 4081 0079 403D 4545 		.string	"@=EEPROM test"
 4081      5052 4F4D 
 4081      2074 6573 
 4081      7400 
 4082               	.global	gTextMsg_HELP_MSG_QM
 4085               	gTextMsg_HELP_MSG_QM:
 4086 0087 3F3D 4350 		.string	"?=CPU stats"
 4086      5520 7374 
 4086      6174 7300 
 4087               	.global	gTextMsg_HELP_MSG_0
 4090               	gTextMsg_HELP_MSG_0:
 4091 0093 303D 5A65 		.string	"0=Zero addr"
 4091      726F 2061 
 4091      6464 7200 
 4092               	.global	gTextMsg_PORT
 4095               	gTextMsg_PORT:
 4096 009f 504F 5254 		.string	"PORT"
 4096      00
 4097               	.global	gTextMsg_EEPROMerrorCnt
 4100               	gTextMsg_EEPROMerrorCnt:
 4101 00a4 4545 2065 		.string	"EE err cnt="
 4101      7272 2063 
 4101      6E74 3D00 
 4102               	.global	gTextMsg_ReadingEEprom
 4105               	gTextMsg_ReadingEEprom:
 4106 00b0 5265 6164 		.string	"Reading EE"
 4106      696E 6720 
 4106      4545 00
 4107               	.global	gTextMsg_WriteToEEprom
 4110               	gTextMsg_WriteToEEprom:
 4111 00bb 5772 6974 		.string	"Writting EE"
 4111      7469 6E67 
 4111      2045 4500 
 4112               	.global	gTextMsg_SPACE
 4115               	gTextMsg_SPACE:
 4116 00c7 2000      		.string	" "
 4117               	.global	gTextMsg_MustBeLetter
 4120               	gTextMsg_MustBeLetter:
 4121 00c9 4D75 7374 		.string	"Must be a letter"
 4121      2062 6520 
 4121      6120 6C65 
 4121      7474 6572 
 4121      00
 4122               	.global	gTextMsg_PortNotSupported
 4125               	gTextMsg_PortNotSupported:
 4126 00da 506F 7274 		.string	"Port not supported"
 4126      206E 6F74 
 4126      2073 7570 
 4126      706F 7274 
 4126      6564 00
 4127               	.global	gTextMsg_WHAT_PORT
 4130               	gTextMsg_WHAT_PORT:
 4131 00ed 5768 6174 		.string	"What port:"
 4131      2070 6F72 
 4131      743A 00
 4132               	.global	gTextMsg_jmp
 4135               	gTextMsg_jmp:
 4136 00f8 6A6D 7020 		.string	"jmp "
 4136      00
 4137               	.global	gTextMsg_rjmp
 4140               	gTextMsg_rjmp:
 4141 00fd 726A 6D70 		.string	"rjmp  "
 4141      2020 00
 4142               	.global	gTextMsg_noVector
 4145               	gTextMsg_noVector:
 4146 0104 6E6F 2076 		.string	"no vector"
 4146      6563 746F 
 4146      7200 
 4147               	.global	gTextMsg_VECTOR_HEADER
 4150               	gTextMsg_VECTOR_HEADER:
 4151 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4151      2041 4444 
 4151      5220 2020 
 4151      6F70 2063 
 4151      6F64 6520 
 4152               	.global	gTextMsg_GCC_VERSION_STR
 4155               	gTextMsg_GCC_VERSION_STR:
 4156 0143 352E 342E 		.string	"5.4.0"
 4156      3000 
 4157               	.global	gTextMsg_AVR_LIBC_VER_STR
 4160               	gTextMsg_AVR_LIBC_VER_STR:
 4161 0149 322E 302E 		.string	"2.0.0"
 4161      3000 
 4162               	.global	gTextMsg_GCC_DATE_STR
 4165               	gTextMsg_GCC_DATE_STR:
 4166 014f 4D61 7220 		.string	"Mar 16 2022"
 4166      3136 2032 
 4166      3032 3200 
 4167               	.global	gTextMsg_FUSE_BYTE_LOCK
 4170               	gTextMsg_FUSE_BYTE_LOCK:
 4171 015b 4C6F 636B 		.string	"Lock fuse   = "
 4171      2066 7573 
 4171      6520 2020 
 4171      3D20 00
 4172               	.global	gTextMsg_FUSE_BYTE_EXT
 4175               	gTextMsg_FUSE_BYTE_EXT:
 4176 016a 4578 7420 		.string	"Ext fuse    = "
 4176      6675 7365 
 4176      2020 2020 
 4176      3D20 00
 4177               	.global	gTextMsg_FUSE_BYTE_HIGH
 4180               	gTextMsg_FUSE_BYTE_HIGH:
 4181 0179 4869 6768 		.string	"High fuse   = "
 4181      2066 7573 
 4181      6520 2020 
 4181      3D20 00
 4182               	.global	gTextMsg_FUSE_BYTE_LOW
 4185               	gTextMsg_FUSE_BYTE_LOW:
 4186 0188 4C6F 7720 		.string	"Low fuse    = "
 4186      6675 7365 
 4186      2020 2020 
 4186      3D20 00
 4187               	.global	gTextMsg_CPU_SIGNATURE
 4190               	gTextMsg_CPU_SIGNATURE:
 4191 0197 4350 5520 		.string	"CPU ID      = "
 4191      4944 2020 
 4191      2020 2020 
 4191      3D20 00
 4192               	.global	gTextMsg_GCC_VERSION
 4195               	gTextMsg_GCC_VERSION:
 4196 01a6 4743 4320 		.string	"GCC Version = "
 4196      5665 7273 
 4196      696F 6E20 
 4196      3D20 00
 4197               	.global	gTextMsg_AVR_LIBC
 4200               	gTextMsg_AVR_LIBC:
 4201 01b5 4156 5220 		.string	"AVR LibC Ver= "
 4201      4C69 6243 
 4201      2056 6572 
 4201      3D20 00
 4202               	.global	gTextMsg_AVR_ARCH
 4205               	gTextMsg_AVR_ARCH:
 4206 01c4 5F5F 4156 		.string	"__AVR_ARCH__= "
 4206      525F 4152 
 4206      4348 5F5F 
 4206      3D20 00
 4207               	.global	gTextMsg_CPU_Type
 4210               	gTextMsg_CPU_Type:
 4211 01d3 4350 5520 		.string	"CPU Type    = "
 4211      5479 7065 
 4211      2020 2020 
 4211      3D20 00
 4212               	.global	gTextMsg_COMPILED_ON
 4215               	gTextMsg_COMPILED_ON:
 4216 01e2 436F 6D70 		.string	"Compiled on = "
 4216      696C 6564 
 4216      206F 6E20 
 4216      3D20 00
 4217               	.global	gTextMsg_HUH
 4220               	gTextMsg_HUH:
 4221 01f1 4875 683F 		.string	"Huh?"
 4221      00
 4222               	.global	gTextMsg_Prompt
 4225               	gTextMsg_Prompt:
 4226 01f6 426F 6F74 		.string	"Bootloader>"
 4226      6C6F 6164 
 4226      6572 3E00 
 4227               	.global	gTextMsg_Explorer
 4230               	gTextMsg_Explorer:
 4231 0202 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4231      696E 6F20 
 4231      6578 706C 
 4231      6F72 6572 
 4231      2073 746B 
 4232               	.global	gTextMsg_CPU_Name
 4235               	gTextMsg_CPU_Name:
 4236 0223 4154 6D65 		.string	"ATmega2560"
 4236      6761 3235 
 4236      3630 00
 4237               		.comm	gEepromIndex,4,1
 4238               		.comm	gFlashIndex,4,1
 4239               		.comm	gRamIndex,4,1
 4240               	.global	app_start
 4241               		.section .bss
 4244               	app_start:
 4245 0000 0000      		.zero	2
 4246               		.text
 4247               	.Letext0:
 4248               		.file 3 "/usr/lib/avr/include/stdint.h"
 4249               		.file 4 "/usr/lib/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/ccd0wCTK.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccd0wCTK.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccd0wCTK.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccd0wCTK.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccd0wCTK.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccd0wCTK.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccd0wCTK.s:12     .text:0000000000000000 sendchar
     /tmp/ccd0wCTK.s:41     .text.unlikely:0000000000000000 recchar
     /tmp/ccd0wCTK.s:64     .init9:0000000000000000 __jumpMain
     /tmp/ccd0wCTK.s:75     *ABS*:00000000000021ff __stack
     /tmp/ccd0wCTK.s:797    .text.startup:0000000000000000 main
     /tmp/ccd0wCTK.s:114    .text:0000000000000018 delay_ms
     /tmp/ccd0wCTK.s:160    .text:0000000000000036 PrintFromPROGMEM_p
     /tmp/ccd0wCTK.s:236    .text:0000000000000070 PrintNewLine
     /tmp/ccd0wCTK.s:257    .text.unlikely:000000000000000e PrintAvailablePort
     /tmp/ccd0wCTK.s:4095   .progmem.data:000000000000009f gTextMsg_PORT
     /tmp/ccd0wCTK.s:295    .text:000000000000007c PrintFromPROGMEMln_p
     /tmp/ccd0wCTK.s:315    .text:0000000000000084 PrintString
     /tmp/ccd0wCTK.s:358    .text:000000000000009c PrintHexByte
     /tmp/ccd0wCTK.s:418    .text.unlikely:0000000000000028 DumpHex.constprop.0
     /tmp/ccd0wCTK.s:700    .text:00000000000000ca PrintDecInt
     /tmp/ccd0wCTK.s:4244   .bss:0000000000000000 app_start
                            *COM*:0000000000000004 gRamIndex
                            *COM*:0000000000000004 gFlashIndex
                            *COM*:0000000000000004 gEepromIndex
     /tmp/ccd0wCTK.s:4230   .progmem.data:0000000000000202 gTextMsg_Explorer
     /tmp/ccd0wCTK.s:4225   .progmem.data:00000000000001f6 gTextMsg_Prompt
     /tmp/ccd0wCTK.s:4085   .progmem.data:0000000000000087 gTextMsg_HELP_MSG_QM
     /tmp/ccd0wCTK.s:4215   .progmem.data:00000000000001e2 gTextMsg_COMPILED_ON
     /tmp/ccd0wCTK.s:4165   .progmem.data:000000000000014f gTextMsg_GCC_DATE_STR
     /tmp/ccd0wCTK.s:4210   .progmem.data:00000000000001d3 gTextMsg_CPU_Type
     /tmp/ccd0wCTK.s:4235   .progmem.data:0000000000000223 gTextMsg_CPU_Name
     /tmp/ccd0wCTK.s:4205   .progmem.data:00000000000001c4 gTextMsg_AVR_ARCH
     /tmp/ccd0wCTK.s:4195   .progmem.data:00000000000001a6 gTextMsg_GCC_VERSION
     /tmp/ccd0wCTK.s:4155   .progmem.data:0000000000000143 gTextMsg_GCC_VERSION_STR
     /tmp/ccd0wCTK.s:4200   .progmem.data:00000000000001b5 gTextMsg_AVR_LIBC
     /tmp/ccd0wCTK.s:4160   .progmem.data:0000000000000149 gTextMsg_AVR_LIBC_VER_STR
     /tmp/ccd0wCTK.s:4190   .progmem.data:0000000000000197 gTextMsg_CPU_SIGNATURE
     /tmp/ccd0wCTK.s:4185   .progmem.data:0000000000000188 gTextMsg_FUSE_BYTE_LOW
     /tmp/ccd0wCTK.s:4180   .progmem.data:0000000000000179 gTextMsg_FUSE_BYTE_HIGH
     /tmp/ccd0wCTK.s:4175   .progmem.data:000000000000016a gTextMsg_FUSE_BYTE_EXT
     /tmp/ccd0wCTK.s:4170   .progmem.data:000000000000015b gTextMsg_FUSE_BYTE_LOCK
     /tmp/ccd0wCTK.s:4055   .progmem.data:000000000000003a gTextMsg_HELP_MSG_L
     /tmp/ccd0wCTK.s:4045   .progmem.data:0000000000000028 gTextMsg_HELP_MSG_R
     /tmp/ccd0wCTK.s:4090   .progmem.data:0000000000000093 gTextMsg_HELP_MSG_0
     /tmp/ccd0wCTK.s:4080   .progmem.data:0000000000000079 gTextMsg_HELP_MSG_AT
     /tmp/ccd0wCTK.s:4110   .progmem.data:00000000000000bb gTextMsg_WriteToEEprom
     /tmp/ccd0wCTK.s:4115   .progmem.data:00000000000000c7 gTextMsg_SPACE
     /tmp/ccd0wCTK.s:4105   .progmem.data:00000000000000b0 gTextMsg_ReadingEEprom
     /tmp/ccd0wCTK.s:4100   .progmem.data:00000000000000a4 gTextMsg_EEPROMerrorCnt
     /tmp/ccd0wCTK.s:4075   .progmem.data:000000000000006d gTextMsg_HELP_MSG_B
     /tmp/ccd0wCTK.s:4070   .progmem.data:000000000000005f gTextMsg_HELP_MSG_E
     /tmp/ccd0wCTK.s:4065   .progmem.data:0000000000000052 gTextMsg_HELP_MSG_F
     /tmp/ccd0wCTK.s:4060   .progmem.data:000000000000004b gTextMsg_HELP_MSG_H
     /tmp/ccd0wCTK.s:4050   .progmem.data:0000000000000033 gTextMsg_HELP_MSG_Q
     /tmp/ccd0wCTK.s:4040   .progmem.data:000000000000000f gTextMsg_HELP_MSG_V
     /tmp/ccd0wCTK.s:4035   .progmem.data:0000000000000002 gTextMsg_HELP_MSG_Y
     /tmp/ccd0wCTK.s:4150   .progmem.data:000000000000010e gTextMsg_VECTOR_HEADER
     /tmp/ccd0wCTK.s:4145   .progmem.data:0000000000000104 gTextMsg_noVector
     /tmp/ccd0wCTK.s:4140   .progmem.data:00000000000000fd gTextMsg_rjmp
     /tmp/ccd0wCTK.s:4135   .progmem.data:00000000000000f8 gTextMsg_jmp
     /tmp/ccd0wCTK.s:4130   .progmem.data:00000000000000ed gTextMsg_WHAT_PORT
     /tmp/ccd0wCTK.s:4125   .progmem.data:00000000000000da gTextMsg_PortNotSupported
     /tmp/ccd0wCTK.s:4120   .progmem.data:00000000000000c9 gTextMsg_MustBeLetter
     /tmp/ccd0wCTK.s:4220   .progmem.data:00000000000001f1 gTextMsg_HUH
     /tmp/ccd0wCTK.s:4022   .rodata:0000000000000000 CSWTCH.68
     /tmp/ccd0wCTK.s:4030   .progmem.data:0000000000000000 gTextMsg_END

UNDEFINED SYMBOLS
eeprom_read_byte
__divmodhi4
__udivmodsi4
eeprom_write_byte
__bswapsi2
__do_copy_data
__do_clear_bss
